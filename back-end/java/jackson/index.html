<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico">
  <link rel="mask-icon" href="/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.lichao.xin","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"3ZZ8ITB7HE","apiKey":"062eb5a54afbcbf3f20452d58fc40035","indexName":"xinlc","hits":{"per_page":10},"labels":{"input_placeholder":"搜索","hits_empty":"未发现与「${query}」相关的内容","hits_stats":"${hits} 条相关条目，使用了 ${time} 毫秒"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Jackson 是用来序列化和反序列化 json 的 Java 的开源框架。Spring MVC 的默认 json 解析器便是 Jackson。与其他 Java 的 json 的框架 Gson 等相比，Jackson 解析大的 json 文件速度比较快；Jackson 运行时占用内存比较低，性能比较好；Jackson 有灵活的 API，可以很容易进行扩展和定制。">
<meta property="og:type" content="article">
<meta property="og:title" content="Jackson 使用详解">
<meta property="og:url" content="https://blog.lichao.xin/back-end/java/jackson/index.html">
<meta property="og:site_name" content="Richard Xin&#39;s Blog">
<meta property="og:description" content="Jackson 是用来序列化和反序列化 json 的 Java 的开源框架。Spring MVC 的默认 json 解析器便是 Jackson。与其他 Java 的 json 的框架 Gson 等相比，Jackson 解析大的 json 文件速度比较快；Jackson 运行时占用内存比较低，性能比较好；Jackson 有灵活的 API，可以很容易进行扩展和定制。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2021-02-28T13:25:00.000Z">
<meta property="article:modified_time" content="2021-06-14T01:33:22.387Z">
<meta property="article:author" content="Richard">
<meta property="article:tag" content="Spring">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://blog.lichao.xin/back-end/java/jackson/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Jackson 使用详解 | Richard Xin's Blog</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4530ac9d0bc4e258535c4a9b17029f0c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Richard Xin's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Richard Xin's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Quick notes</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">132</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">59</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">12</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.lichao.xin/back-end/java/jackson/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/18113256?v=3&s=460">
      <meta itemprop="name" content="Richard">
      <meta itemprop="description" content="惶者生存，偏执者成功">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Richard Xin's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Jackson 使用详解
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-02-28 13:25:00" itemprop="dateCreated datePublished" datetime="2021-02-28T13:25:00+00:00">2021-02-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-14 01:33:22" itemprop="dateModified" datetime="2021-06-14T01:33:22+00:00">2021-06-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Jackson 是用来序列化和反序列化 json 的 Java 的开源框架。Spring MVC 的默认 json 解析器便是 Jackson。与其他 Java 的 json 的框架 Gson 等相比，Jackson 解析大的 json 文件速度比较快；Jackson 运行时占用内存比较低，性能比较好；Jackson 有灵活的 API，可以很容易进行扩展和定制。</p>
<a id="more"></a>

<h2 id="常见的JSON解析类库"><a href="#常见的JSON解析类库" class="headerlink" title="常见的JSON解析类库"></a>常见的JSON解析类库</h2><ul>
<li>fastjson：阿里出品的一个JSON解析类库，很快，提供了很多静态方法使用方便，但是底层实现不是很好，解析过程中使用String的substring，性能很好，但是可能会导致内存泄漏。</li>
<li>Gson：谷歌出品的JSON解析类库，但是性能相较于其他连个稍微差点。</li>
<li>Jackson：相对比较推荐的一种JSON解析类库，性能好稳定。</li>
</ul>
<blockquote>
<p>Spring MVC 默认采用Jackson解析Json，尽管还有一些其它同样优秀的json解析工具，例如Fast Json、GSON，但是出于最小依赖的考虑，也许Json解析第一选择就应该是Jackson。</p>
</blockquote>
<h2 id="Jackson-简介"><a href="#Jackson-简介" class="headerlink" title="Jackson 简介"></a>Jackson 简介</h2><p>Jackson 是当前用的比较广泛的，用来序列化和反序列化 json 的 Java 的开源框架。Jackson 社区相对比较活跃，更新速度也比较快， 从 Github 中的统计来看，Jackson 是最流行的 json 解析器之一 。 Spring MVC 的默认 json 解析器便是 Jackson。 Jackson 优点很多。 Jackson 所依赖的 jar 包较少 ，简单易用。与其他 Java 的 json 的框架 Gson 等相比， Jackson 解析大的 json 文件速度比较快；Jackson 运行时占用内存比较低，性能比较好；Jackson 有灵活的 API，可以很容易进行扩展和定制。</p>
<p>Jackson 的 1.x 版本的包名是 org.codehaus.jackson ，当升级到 2.x 版本时，包名变为 com.fasterxml.jackson。</p>
<p>Jackson 的核心模块由三部分组成。</p>
<ul>
<li>jackson-core，核心包，提供基于”流模式”解析的相关 API，它包括 JsonPaser 和 JsonGenerator。 Jackson 内部实现正是通过高性能的流模式 API 的 JsonGenerator 和 JsonParser 来生成和解析 json。</li>
<li>jackson-annotations，注解包，提供标准注解功能；</li>
<li>jackson-databind ，数据绑定包， 提供基于”对象绑定” 解析的相关 API （ ObjectMapper ） 和”树模型” 解析的相关 API （JsonNode）；基于”对象绑定” 解析的 API 和”树模型”解析的 API 依赖基于”流模式”解析的 API。</li>
</ul>
<p>源码地址：<a href="https://github.com/FasterXML/jackson" target="_blank" rel="noopener">FasterXML/jackson</a></p>
<h2 id="Maven-依赖"><a href="#Maven-依赖" class="headerlink" title="Maven 依赖"></a>Maven 依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 其中Jackson Annotations依赖Jackson Core，Jackson Databind依赖Jackson Annotations。--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当然了，jackson-databind 依赖 jackson-core 和 jackson-annotations，所以可以只显示地添加jackson-databind依赖，jackson-core 和 jackson-annotations 也随之添加到 Java 项目工程中。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="ObjectMapper"><a href="#ObjectMapper" class="headerlink" title="ObjectMapper"></a>ObjectMapper</h2><p>Jackson 最常用的 API 就是基于”对象绑定” 的 ObjectMapper：</p>
<ul>
<li>ObjectMapper可以从字符串，流或文件中解析JSON，并创建表示已解析的JSON的Java对象。 将JSON解析为Java对象也称为从JSON反序列化Java对象。</li>
<li>ObjectMapper也可以从Java对象创建JSON。 从Java对象生成JSON也称为将Java对象序列化为JSON。</li>
<li>Object映射器可以将JSON解析为自定义的类的对象，也可以解析置JSON树模型的对象。</li>
</ul>
<p>之所以称为ObjectMapper是因为它将JSON映射到Java对象（反序列化），或者将Java对象映射到JSON（序列化）。</p>
<h3 id="从JSON中获取Java对象"><a href="#从JSON中获取Java对象" class="headerlink" title="从JSON中获取Java对象"></a>从JSON中获取Java对象</h3><h4 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h4><p>一个简单的例子：</p>
<p>Car类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line"> <span class="keyword">private</span> String brand = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> doors = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBrand</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.brand; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>   <span class="title">setBrand</span><span class="params">(String brand)</span></span>&#123; <span class="keyword">this</span>.brand = brand;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>  <span class="title">getDoors</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.doors; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDoors</span> <span class="params">(<span class="keyword">int</span> doors)</span> </span>&#123; <span class="keyword">this</span>.doors = doors; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将Json转换为Car类对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">String carJson = <span class="string">"&#123; \"brand\" : \"Mercedes\", \"doors\" : 5 &#125;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Car car = objectMapper.readValue(carJson, Car<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"car brand = "</span> + car.getBrand());</span><br><span class="line">    System.out.println(<span class="string">"car doors = "</span> + car.getDoors());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ObjectMapper如何匹配JSON对象的字段和Java对象的属性"><a href="#ObjectMapper如何匹配JSON对象的字段和Java对象的属性" class="headerlink" title="ObjectMapper如何匹配JSON对象的字段和Java对象的属性"></a>ObjectMapper如何匹配JSON对象的字段和Java对象的属性</h4><p>默认情况下，Jackson通过将JSON字段的名称与Java对象中的getter和setter方法进行匹配，将JSON对象的字段映射到Java对象中的属性。 Jackson删除了getter和setter方法名称的“ get”和“ set”部分，并将其余名称的第一个字符转换为小写。</p>
<p>例如，名为brand的JSON字段与名为getBrand()和setBrand()的Java  getter和setter方法匹配。 名为engineNumber的JSON字段将与名为getEngineNumber()和setEngineNumber()的getter和setter匹配。</p>
<p>如果需要以其他方式将JSON对象字段与Java对象字段匹配，则需要使用自定义序列化器和反序列化器，或者使用一些Jackson注解。</p>
<h4 id="JSON字符串–-gt-Java对象"><a href="#JSON字符串–-gt-Java对象" class="headerlink" title="JSON字符串–&gt;Java对象"></a>JSON字符串–&gt;Java对象</h4><p>从JSON字符串读取Java对象非常容易。 上面已经有了一个示例——JSON字符串作为第一个参数传递给ObjectMapper的readValue()方法。 这是另一个简单的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">String carJson = <span class="string">"&#123; \"brand\" : \"Mercedes\", \"doors\" : 5 &#125;"</span>;</span><br><span class="line"></span><br><span class="line">Car car = objectMapper.readValue(carJson, Car<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="JSON-字符输入流–-gt-Java对象"><a href="#JSON-字符输入流–-gt-Java对象" class="headerlink" title="JSON 字符输入流–&gt;Java对象"></a>JSON 字符输入流–&gt;Java对象</h4><p>还可以从通过Reader实例加载的JSON中读取对象。示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">String carJson = <span class="string">"&#123; \"brand\" : \"Mercedes\", \"doors\" : 4 &#125;"</span>;</span><br><span class="line">Reader reader = <span class="keyword">new</span> StringReader(carJson);</span><br><span class="line"></span><br><span class="line">Car car = objectMapper.readValue(reader, Car<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="JSON文件–-gt-Java对象"><a href="#JSON文件–-gt-Java对象" class="headerlink" title="JSON文件–&gt;Java对象"></a>JSON文件–&gt;Java对象</h4><p>从文件读取JSON当然可以通过FileReader（而不是StringReader）来完成，也可以通过File对象来完成。 这是从文件读取JSON的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"data/car.json"</span>);</span><br><span class="line"></span><br><span class="line">Car car = objectMapper.readValue(file, Car<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="JSON-via-URL—-gt-Java对象"><a href="#JSON-via-URL—-gt-Java对象" class="headerlink" title="JSON via URL—&gt;Java对象"></a>JSON via URL—&gt;Java对象</h4><p>可以通过URL（java.net.URL）从JSON读取对象，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">URL url = <span class="keyword">new</span> URL(<span class="string">"file:data/car.json"</span>);</span><br><span class="line"></span><br><span class="line">Car car = objectMapper.readValue(url, Car<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>示例使用文件URL，也可以使用HTTP URL（类似于<a href="http://jenkov.com/some-data.json）。" target="_blank" rel="noopener">http://jenkov.com/some-data.json）。</a></p>
<h4 id="JSON字节输入流–-gt-Java对象"><a href="#JSON字节输入流–-gt-Java对象" class="headerlink" title="JSON字节输入流–&gt;Java对象"></a>JSON字节输入流–&gt;Java对象</h4><p>也可以使用ObjectMapper通过InputStream从JSON读取对象。 这是一个从InputStream读取JSON的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">InputStream input = <span class="keyword">new</span> FileInputStream(<span class="string">"data/car.json"</span>);</span><br><span class="line"></span><br><span class="line">Car car = objectMapper.readValue(input, Car<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="JSON二进制数组–-gt-Java对象"><a href="#JSON二进制数组–-gt-Java对象" class="headerlink" title="JSON二进制数组–&gt;Java对象"></a>JSON二进制数组–&gt;Java对象</h4><p>Jackson还支持从JSON字节数组读取对象。 这是从JSON字节数组读取对象的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">String carJson = <span class="string">"&#123; \"brand\" : \"Mercedes\", \"doors\" : 5 &#125;"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] bytes = carJson.getBytes(<span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line">Car car = objectMapper.readValue(bytes, Car<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<h4 id="JSON数组字符串–-gt-Java对象数组"><a href="#JSON数组字符串–-gt-Java对象数组" class="headerlink" title="JSON数组字符串–&gt;Java对象数组"></a>JSON数组字符串–&gt;Java对象数组</h4><p>Jackson ObjectMapper也可以从JSON数组字符串读取对象数组。 这是从JSON数组字符串读取对象数组的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String jsonArray = <span class="string">"[&#123;\"brand\":\"ford\"&#125;, &#123;\"brand\":\"Fiat\"&#125;]"</span>;</span><br><span class="line"></span><br><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">Car[] cars2 = objectMapper.readValue(jsonArray, Car[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>需要将Car数组类作为第二个参数传递给readValue()方法。</p>
<p>读取对象数组还可以与字符串以外的其他JSON源一起使用。 例如，文件，URL，InputStream，Reader等。</p>
<h4 id="JSON数组字符串–-gt-List"><a href="#JSON数组字符串–-gt-List" class="headerlink" title="JSON数组字符串–&gt;List"></a>JSON数组字符串–&gt;List</h4><p>Jackson ObjectMapper还可以从JSON数组字符串读取对象的Java List。 这是从JSON数组字符串读取对象列表的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String jsonArray = <span class="string">"[&#123;\"brand\":\"ford\"&#125;, &#123;\"brand\":\"Fiat\"&#125;]"</span>;</span><br><span class="line"></span><br><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">List&lt;Car&gt; cars1 = objectMapper.readValue(jsonArray, <span class="keyword">new</span> TypeReference&lt;List&lt;Car&gt;&gt;()&#123;&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="JSON字符串–-gt-Map"><a href="#JSON字符串–-gt-Map" class="headerlink" title="JSON字符串–&gt;Map"></a>JSON字符串–&gt;Map</h4><p>Jackson ObjectMapper还可以从JSON字符串读取Java Map。 如果事先不知道将要解析的确切JSON结构，这种方法是很有用的。 通常，会将JSON对象读入Java Map。 JSON对象中的每个字段都将成为Java Map中的键，值对。</p>
<p>这是一个使用Jackson ObjectMapper从JSON字符串读取Java Map的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String jsonObject = <span class="string">"&#123;\"brand\":\"ford\", \"doors\":5&#125;"</span>;</span><br><span class="line"></span><br><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">Map&lt;String, Object&gt; jsonMap = objectMapper.readValue(jsonObject,</span><br><span class="line">    <span class="keyword">new</span> TypeReference&lt;Map&lt;String,Object&gt;&gt;()&#123;&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="忽略未知的JSON字段"><a href="#忽略未知的JSON字段" class="headerlink" title="忽略未知的JSON字段"></a>忽略未知的JSON字段</h4><p>有时候，与要从JSON读取的Java对象相比，JSON中的字段更多。 默认情况下，Jackson在这种情况下会抛出异常，报不知道XYZ字段异常，因为在Java对象中找不到该字段。</p>
<p>但是，有时应该允许JSON中的字段多于相应的Java对象中的字段。 例如，要从REST服务解析JSON，而该REST服务包含的数据远远超出所需的。 在这种情况下，可以使用Jackson配置忽略这些额外的字段。 以下是配置Jackson ObjectMapper忽略未知字段的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objectMapper.configure(</span><br><span class="line">    DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>

<h4 id="不允许基本类型为null"><a href="#不允许基本类型为null" class="headerlink" title="不允许基本类型为null"></a>不允许基本类型为null</h4><p>如果JSON字符串包含其值设置为null的字段（对于在相应的Java对象中是基本数据类型（int，long，float，double等）的字段），Jackson ObjectMapper默认会处理基本数据类型为null的情况，我们可以可以将Jackson ObjectMapper默认配置为失效，这样基本数据为null就会转换失败。 例如以下Car类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String brand = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> doors = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getBrand</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.brand; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>   <span class="title">setBrand</span><span class="params">(String brand)</span></span>&#123; <span class="keyword">this</span>.brand = brand;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span>  <span class="title">getDoors</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.doors; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDoors</span> <span class="params">(<span class="keyword">int</span> doors)</span> </span>&#123; <span class="keyword">this</span>.doors = doors; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>doors字段是一个int类型，它是Java中的基本数据类型。</p>
<p>现在，假设有一个与Car对象相对应的JSON字符串，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="string">"brand"</span>:<span class="string">"Toyota"</span>, <span class="string">"doors"</span>:<span class="keyword">null</span> &#125;</span><br></pre></td></tr></table></figure>

<p>请注意，doors字段值为null。 Java中的基本数据类型不能为null值。 默认情况下，Jackson ObjectMapper会忽略原始字段的空值。 但是，可以将Jackson ObjectMapper配置设置为失败。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">objectMapper.configure(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES, <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>在FAIL_ON_NULL_FOR_PRIMITIVES配置值设置为true的情况下，尝试将空JSON字段解析为基本类型Java字段时会遇到异常。 这是一个Java Jackson ObjectMapper示例，该示例将失败，因为JSON字段包含原始Java字段的空值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">objectMapper.configure(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">String carJson = <span class="string">"&#123; \"brand\":\"Toyota\", \"doors\":null &#125;"</span>;</span><br><span class="line"></span><br><span class="line">Car car = objectMapper.readValue(carJson, Car<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>会报错：MismatchedInputException</p>
</blockquote>
<h4 id="自定义反序列化"><a href="#自定义反序列化" class="headerlink" title="自定义反序列化"></a>自定义反序列化</h4><p>有时，可能希望以不同于Jackson ObjectMapper缺省方式的方式将JSON字符串读入Java对象。 可以将自定义反序列化器添加到ObjectMapper，可以按需要执行反序列化。</p>
<p>这是在Jackson的ObjectMapper中注册和使用自定义反序列化器的方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String json = <span class="string">"&#123; \"brand\" : \"Ford\", \"doors\" : 6 &#125;"</span>;</span><br><span class="line"></span><br><span class="line">SimpleModule <span class="keyword">module</span> =</span><br><span class="line">        <span class="keyword">new</span> SimpleModule(<span class="string">"CarDeserializer"</span>, <span class="keyword">new</span> Version(<span class="number">3</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>));</span><br><span class="line"><span class="keyword">module</span>.addDeserializer(Car<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">CarDeserializer</span>(<span class="title">Car</span>.<span class="title">class</span>))</span>;</span><br><span class="line"></span><br><span class="line">ObjectMapper mapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">mapper.registerModule(<span class="keyword">module</span>);</span><br><span class="line"></span><br><span class="line">Car car = mapper.readValue(json, Car<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>

<p>自定义反序列化器CarDeserializer类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarDeserializer</span> <span class="keyword">extends</span> <span class="title">StdDeserializer</span>&lt;<span class="title">Car</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CarDeserializer</span><span class="params">(Class&lt;?&gt; vc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(vc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">deserialize</span><span class="params">(JsonParser parser, DeserializationContext deserializer)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Car car = <span class="keyword">new</span> Car();</span><br><span class="line">        <span class="keyword">while</span>(!parser.isClosed())&#123;</span><br><span class="line">            JsonToken jsonToken = parser.nextToken();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(JsonToken.FIELD_NAME.equals(jsonToken))&#123;</span><br><span class="line">                String fieldName = parser.getCurrentName();</span><br><span class="line">                System.out.println(fieldName);</span><br><span class="line"></span><br><span class="line">                jsonToken = parser.nextToken();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(<span class="string">"brand"</span>.equals(fieldName))&#123;</span><br><span class="line">                    car.setBrand(parser.getValueAsString());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"doors"</span>.equals(fieldName))&#123;</span><br><span class="line">                    car.setDoors(parser.getValueAsInt());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> car;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="将对象写入JSON"><a href="#将对象写入JSON" class="headerlink" title="将对象写入JSON"></a>将对象写入JSON</h3><h4 id="Java对象–-gt-JSON"><a href="#Java对象–-gt-JSON" class="headerlink" title="Java对象–&gt;JSON"></a>Java对象–&gt;JSON</h4><p>Jackson ObjectMapper也可以用于从对象生成JSON。 可以使用以下方法之一进行操作：</p>
<ul>
<li>writeValue()</li>
<li>writeValueAsString()</li>
<li>writeValueAsBytes()</li>
</ul>
<p>这是一个从Car对象生成JSON的示例，和上面的实例相反：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">  Car car = <span class="keyword">new</span> Car();</span><br><span class="line">  car.setBrand(<span class="string">"BMW"</span>);</span><br><span class="line">  car.setDoors(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">  objectMapper.writeValue(</span><br><span class="line">      <span class="keyword">new</span> FileOutputStream(<span class="string">"data/output-2.json"</span>), car);</span><br></pre></td></tr></table></figure>

<p>此示例首先创建一个ObjectMapper，然后创建一个Car实例，最后调用ObjectMapper的writeValue()方法，该方法将Car对象转换为JSON并将其写入给定的FileOutputStream。</p>
<p>ObjectMapper的writeValueAsString()和writeValueAsBytes()都从一个对象生成JSON，并将生成的JSON作为String或字节数组返回。 示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">Car car = <span class="keyword">new</span> Car();</span><br><span class="line">car.setBrand(<span class="string">"宝马"</span>);</span><br><span class="line">car.setDoors(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">String json = objectMapper.writeValueAsString(car);</span><br><span class="line">System.out.println(json);</span><br></pre></td></tr></table></figure>

<h4 id="自定义序列化"><a href="#自定义序列化" class="headerlink" title="自定义序列化"></a>自定义序列化</h4><p>有时，想要将Java对象序列化为JSON的方式与使用Jackson的默认方式不同。例如，可能想要在JSON中使用与Java对象中不同的字段名称，或者希望完全省略某些字段。</p>
<p>Jackson可以在ObjectMapper上设置自定义序列化器。该序列化器已为某个类注册，然后在每次要求ObjectMapper序列化Car对象时将调用该序列化器。</p>
<p>这是为Car类注册自定义序列化器的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">CarSerializer carSerializer = <span class="keyword">new</span> CarSerializer(Car<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">SimpleModule <span class="keyword">module</span> =</span><br><span class="line">        <span class="keyword">new</span> SimpleModule(<span class="string">"CarSerializer"</span>, <span class="keyword">new</span> Version(<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>));</span><br><span class="line"><span class="keyword">module</span>.addSerializer(Car<span class="class">.<span class="keyword">class</span>, <span class="title">carSerializer</span>)</span>;</span><br><span class="line"></span><br><span class="line">objectMapper.registerModule(<span class="keyword">module</span>);</span><br><span class="line"></span><br><span class="line">Car car = <span class="keyword">new</span> Car();</span><br><span class="line">car.setBrand(<span class="string">"Mercedes"</span>);</span><br><span class="line">car.setDoors(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">String carJson = objectMapper.writeValueAsString(car);</span><br></pre></td></tr></table></figure>

<p>自定义序列化器CarSerializer类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarSerializer</span> <span class="keyword">extends</span> <span class="title">StdSerializer</span>&lt;<span class="title">Car</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">CarSerializer</span><span class="params">(Class&lt;Car&gt; t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(Car car, JsonGenerator jsonGenerator,</span></span></span><br><span class="line"><span class="function"><span class="params">                          SerializerProvider serializerProvider)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        jsonGenerator.writeStartObject();</span><br><span class="line">        jsonGenerator.writeStringField(<span class="string">"producer"</span>, car.getBrand());</span><br><span class="line">        jsonGenerator.writeNumberField(<span class="string">"doorCount"</span>, car.getDoors());</span><br><span class="line">        jsonGenerator.writeEndObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Jackson-日期转化"><a href="#Jackson-日期转化" class="headerlink" title="Jackson 日期转化"></a>Jackson 日期转化</h3><p>默认情况下，Jackson会将java.util.Date对象序列化为其long型的值，该值是自1970年1月1日以来的毫秒数。但是，Jackson还支持将日期格式化为字符串。</p>
<h4 id="Date–-gt-long"><a href="#Date–-gt-long" class="headerlink" title="Date–&gt;long"></a>Date–&gt;long</h4><p>默认的Jackson日期格式，该格式将Date序列化为自1970年1月1日以来的毫秒数（long类型）。</p>
<p>这是一个包含Date字段的Java类示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String type = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> Date date = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Transaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Transaction</span><span class="params">(String type, Date date)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = type;</span><br><span class="line">    <span class="keyword">this</span>.date = date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.type = type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getDate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> date;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDate</span><span class="params">(Date date)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.date = date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就像使用其他Java对象进行序列化一样，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Transaction transaction = <span class="keyword">new</span> Transaction(<span class="string">"transfer"</span>, <span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">String output = objectMapper.writeValueAsString(transaction);</span><br><span class="line"></span><br><span class="line">System.out.println(output);</span><br></pre></td></tr></table></figure>

<h4 id="Date–-gt-String"><a href="#Date–-gt-String" class="headerlink" title="Date–&gt;String"></a>Date–&gt;String</h4><p>日期的long序列化格式不符合人类的时间查看格式。 因此，Jackson也支持文本日期格式。 可以通过在ObjectMapper上设置SimpleDateFormat来指定要使用的确切Jackson日期格式。 这是在Jackson的ObjectMapper上设置SimpleDateFormat的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Transaction transaction = <span class="keyword">new</span> Transaction(<span class="string">"transfer"</span>, <span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">objectMapper.setDateFormat(dateFormat);</span><br><span class="line"></span><br><span class="line">String output2 = objectMapper.writeValueAsString(transaction);</span><br><span class="line">System.out.println(output2);</span><br></pre></td></tr></table></figure>

<h3 id="Jackson-JSON-树模型"><a href="#Jackson-JSON-树模型" class="headerlink" title="Jackson JSON 树模型"></a>Jackson JSON 树模型</h3><p>Jackson具有内置的树模型，可用于表示JSON对象。 如果不知道接收到的JSON的格式，或者由于某种原因而不能（或者只是不想）创建一个类来表示它，那么就要用到Jackson的树模型。 如果需要在使用或转化JSON之前对其进行操作，也需要被用到Jackson树模型。 所有这些情况在数据流场景中都很常见。</p>
<p>Jackson树模型由JsonNode类表示。 您可以使用Jackson ObjectMapper将JSON解析为JsonNode树模型，就像使用您自己的类一样。</p>
<p>以下将展示如何使用Jackson ObjectMapper读写JsonNode实例。</p>
<h4 id="Jackson-Tree-Model简单例子"><a href="#Jackson-Tree-Model简单例子" class="headerlink" title="Jackson Tree Model简单例子"></a>Jackson Tree Model简单例子</h4><p>下面是一个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String carJson = <span class="string">"&#123; \"brand\" : \"Mercedes\", \"doors\" : 5 &#125;"</span>;</span><br><span class="line"></span><br><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">    JsonNode jsonNode = objectMapper.readValue(carJson, JsonNode<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只需将JsonNode.class作为第二个参数传递给readValue()方法，而不是本教程前面的示例中使用的Car.class，就可以将JSON字符串解析为JsonNode对象而不是Car对象。 。</p>
<p>ObjectMapper类还具有一个特殊的readTree()方法，该方法返回JsonNode。 这是使用ObjectMapper readTree()方法将JSON解析为JsonNode的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String carJson = <span class="string">"&#123; \"brand\" : \"Mercedes\", \"doors\" : 5 &#125;"</span>;</span><br><span class="line"></span><br><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">    JsonNode jsonNode = objectMapper.readTree(carJson);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Jackson-JsonNode类"><a href="#Jackson-JsonNode类" class="headerlink" title="Jackson JsonNode类"></a>Jackson JsonNode类</h4><p>通过JsonNode类，可以以非常灵活和动态的方式将JSON作为Java对象导航。这里了解一些如何使用它的基础知识。</p>
<p>将JSON解析为JsonNode（或JsonNode实例树）后，就可以浏览JsonNode树模型。 这是一个JsonNode示例，显示了如何访问JSON字段，数组和嵌套对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">String carJson =</span><br><span class="line">        <span class="string">"&#123; \"brand\" : \"Mercedes\", \"doors\" : 5,"</span> +</span><br><span class="line">        <span class="string">"  \"owners\" : [\"John\", \"Jack\", \"Jill\"],"</span> +</span><br><span class="line">        <span class="string">"  \"nestedObject\" : &#123; \"field\" : \"value\" &#125; &#125;"</span>;</span><br><span class="line"></span><br><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">    JsonNode jsonNode = objectMapper.readValue(carJson, JsonNode<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    JsonNode brandNode = jsonNode.get(<span class="string">"brand"</span>);</span><br><span class="line">    String brand = brandNode.asText();</span><br><span class="line">    System.out.println(<span class="string">"brand = "</span> + brand);</span><br><span class="line"></span><br><span class="line">    JsonNode doorsNode = jsonNode.get(<span class="string">"doors"</span>);</span><br><span class="line">    <span class="keyword">int</span> doors = doorsNode.asInt();</span><br><span class="line">    System.out.println(<span class="string">"doors = "</span> + doors);</span><br><span class="line"></span><br><span class="line">    JsonNode array = jsonNode.get(<span class="string">"owners"</span>);</span><br><span class="line">    JsonNode jsonNode = array.get(<span class="number">0</span>);</span><br><span class="line">    String john = jsonNode.asText();</span><br><span class="line">    System.out.println(<span class="string">"john  = "</span> + john);</span><br><span class="line"></span><br><span class="line">    JsonNode child = jsonNode.get(<span class="string">"nestedObject"</span>);</span><br><span class="line">    JsonNode childField = child.get(<span class="string">"field"</span>);</span><br><span class="line">    String field = childField.asText();</span><br><span class="line">    System.out.println(<span class="string">"field = "</span> + field);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，JSON字符串现在包含一个称为owners的数组字段和一个称为nestedObject的嵌套对象字段。</p>
<p>无论访问的是字段，数组还是嵌套对象，都可以使用JsonNode类的get()方法。 通过将字符串作为参数提供给get()方法，可以访问JsonNode的字段。 如果JsonNode表示数组，则需要将索引传递给get()方法。 索引指定要获取的数组元素。</p>
<h4 id="Java对象–-gt-JsonNode"><a href="#Java对象–-gt-JsonNode" class="headerlink" title="Java对象–&gt;JsonNode"></a>Java对象–&gt;JsonNode</h4><p>可以使用Jackson ObjectMapper将Java对象转换为JsonNode，而JsonNode是转换后的Java对象的JSON表示形式。 可以通过Jackson ObjectMapper valueToTree()方法将Java对象转换为JsonNode。 这是一个使用ObjectMapper valueToTree()方法将Java对象转换为JsonNode的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">Car car = <span class="keyword">new</span> Car();</span><br><span class="line">car.brand = <span class="string">"Cadillac"</span>;</span><br><span class="line">car.doors = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">JsonNode carJsonNode = objectMapper.valueToTree(car);</span><br></pre></td></tr></table></figure>

<h4 id="JsonNode–-gt-Java对象"><a href="#JsonNode–-gt-Java对象" class="headerlink" title="JsonNode–&gt;Java对象"></a>JsonNode–&gt;Java对象</h4><p>可以使用Jackson  ObjectMapper treeToValue()方法将JsonNode转换为Java对象。 这类似于使用Jackson Jackson的ObjectMapper将JSON字符串（或其他来源）解析为Java对象。 唯一的区别是，JSON源是JsonNode。 这是一个使用Jackson ObjectMapper treeToValue()方法将JsonNode转换为Java对象的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">String carJson = <span class="string">"&#123; \"brand\" : \"Mercedes\", \"doors\" : 5 &#125;"</span>;</span><br><span class="line"></span><br><span class="line">JsonNode carJsonNode = objectMapper.readTree(carJson);</span><br><span class="line"></span><br><span class="line">Car car = objectMapper.treeToValue(carJsonNode);</span><br></pre></td></tr></table></figure>

<p>上面的示例有点“人为”，因为我们首先将JSON字符串转换为JsonNode，然后将JsonNode转换为Car对象。 显然，如果我们有对原始JSON字符串的引用，则最好将其直接转换为Car对象，而无需先将其转换为JsonNode。</p>
<h2 id="JsonNode"><a href="#JsonNode" class="headerlink" title="JsonNode"></a>JsonNode</h2><p>Jackson JsonNode类com.fasterxml.jackson.databind.JsonNode是Jackson的JSON树形模型（对象图模型）。 Jackson可以将JSON读取到JsonNode实例中，然后将JsonNode写入JSON。 因此，这一节将说明如何将JSON反序列化为JsonNode以及将JsonNode序列化为JSON。 此Jackson JsonNode教程还将说明如何从头开始构建JsonNode对象图，因此以后可以将它们序列化为JSON。</p>
<h3 id="JsonNode-vs-ObjectNode"><a href="#JsonNode-vs-ObjectNode" class="headerlink" title="JsonNode vs ObjectNode"></a>JsonNode vs ObjectNode</h3><p>Jackson JsonNode类是不可变的。 这意味着，实际上不能直接构建JsonNode实例的对象图。 而是创建JsonNode子类ObjectNode的对象图。 作为JsonNode的子类，可以在可以使用JsonNode的任何地方使用ObjectNode。</p>
<h3 id="JSON–-gt-JsonNode"><a href="#JSON–-gt-JsonNode" class="headerlink" title="JSON–&gt;JsonNode"></a>JSON–&gt;JsonNode</h3><p>要使用Jackson将JSON读取到JsonNode中，首先需要创建一个Jackson ObjectMapper实例。 在ObjectMapper实例上，调用readTree()并将JSON源作为参数传递。 这是将JSON反序列化为JsonNode的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String json = <span class="string">"&#123; \"f1\" : \"v1\" &#125; "</span>;</span><br><span class="line"></span><br><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">JsonNode jsonNode = objectMapper.readTree(json);</span><br><span class="line"></span><br><span class="line">System.out.println(jsonNode.get(<span class="string">"f1"</span>).asText());</span><br></pre></td></tr></table></figure>

<h3 id="JsonNode–-gt-JSON"><a href="#JsonNode–-gt-JSON" class="headerlink" title="JsonNode–&gt;JSON"></a>JsonNode–&gt;JSON</h3><p>要将Jackson的JsonNode写入JSON，还需要一个Jackson ObjectMapper实例。 在ObjectMapper上，调用writeValueAsString()方法或任何适合需要的写入方法。 这是将JsonNode写入JSON的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">JsonNode jsonNode = readJsonIntoJsonNode();</span><br><span class="line"></span><br><span class="line">String json = objectMapper.writeValueAsString(jsonNode);</span><br></pre></td></tr></table></figure>

<h3 id="获取JsonNode字段"><a href="#获取JsonNode字段" class="headerlink" title="获取JsonNode字段"></a>获取JsonNode字段</h3><p>JsonNode可以像JSON对象一样具有字段。 假设已将以下JSON解析为JsonNode：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"field1"</span> : <span class="string">"value1"</span>,</span><br><span class="line">    <span class="attr">"field2"</span> : <span class="number">999</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此JSON对象具有两个名为field1和field2的字段。 如果有一个表示上述JSON对象的Jackson JsonNode，则可以这样获得两个字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JsonNode jsonNode = ... <span class="comment">//parse above JSON into a JsonNode</span></span><br><span class="line"></span><br><span class="line">JsonNode field1 = jsonNode.get(<span class="string">"field1"</span>);</span><br><span class="line">JsonNode field2 = jsonNode.get(<span class="string">"field2"</span>);</span><br></pre></td></tr></table></figure>

<p>请注意，即使两个字段都是String字段，get()方法也始终返回JsonNode来表示该字段。</p>
<h3 id="在路径中获取JsonNode字段"><a href="#在路径中获取JsonNode字段" class="headerlink" title="在路径中获取JsonNode字段"></a>在路径中获取JsonNode字段</h3><p>Jackson JsonNode有一个称为at()的特殊方法。 at()方法可以从JSON图中以给定JsonNode为根的任何位置访问JSON字段。 假设JSON结构如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"identification"</span> :  &#123;</span><br><span class="line">        <span class="attr">"name"</span> : <span class="string">"James"</span>,</span><br><span class="line">        "ssn: "ABC123552"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果将此JSON解析为JsonNode，则可以使用at()方法访问名称字段，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JsonNode nameNode = jsonNode.at(<span class="string">"/identification/name"</span>);</span><br></pre></td></tr></table></figure>

<p>注意传递给at()方法的参数：字符串/ identification / name。 这是一个JSON路径表达式。 此路径表达式指定从根JsonNode到您要访问其值的字段的完整路径。 这类似于从文件系统根目录到Unix文件系统中文件的路径。</p>
<p>请注意，JSON路径表达式必须以斜杠字符（/字符）开头。</p>
<p>at()方法返回一个JsonNode，它表示请求的JSON字段。 要获取该字段的实际值，需要调用下一部分介绍的方法之一。 如果没有节点与给定的路径表达式匹配，则将返回null。</p>
<h3 id="转换JsonNode字段"><a href="#转换JsonNode字段" class="headerlink" title="转换JsonNode字段"></a>转换JsonNode字段</h3><p>Jackson JsonNode类包含一组可以将字段值转换为另一种数据类型的方法。 例如，将String字段值转换为long或相反。 这是将JsonNode字段转换为一些更常见的数据类型的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String f2Str = jsonNode.get(<span class="string">"f2"</span>).asText();</span><br><span class="line"><span class="keyword">double</span> f2Dbl = jsonNode.get(<span class="string">"f2"</span>).asDouble();</span><br><span class="line"><span class="keyword">int</span>    f2Int = jsonNode.get(<span class="string">"f2"</span>).asInt();</span><br><span class="line"><span class="keyword">long</span>   f2Lng = jsonNode.get(<span class="string">"f2"</span>).asLong();</span><br></pre></td></tr></table></figure>

<p>使用默认值转换: 如果JsonNode中的字段可以为null，则在尝试转换它时可以提供默认值。 这是使用默认值调用转换方法的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">String json = <span class="string">"&#123; \"f1\":\"Hello\", \"f2\":null &#125;"</span>;</span><br><span class="line"></span><br><span class="line">JsonNode jsonNode = objectMapper.readTree(json);</span><br><span class="line"></span><br><span class="line">String f2Value = jsonNode.get(<span class="string">"f2"</span>).asText(<span class="string">"Default"</span>);</span><br></pre></td></tr></table></figure>

<p>在示例的JSON字符串中可以看到，声明了f2字段，但将其设置为null。 在这种情况下，调用jsonNode.get（“ f2”）。asText（“ Default”）将返回默认值，在此示例中为字符串Default。</p>
<p>asDouble()，asInt()和asLong()方法还可以采用默认参数值，如果尝试从中获取值的字段为null，则将返回默认参数值。</p>
<p>请注意，如果该字段在JSON中未显式设置为null，但在JSON中丢失，则调用jsonNode.get（“ fieldName”）将返回Java null值，您无法在该Java值上调用asInt() ，asDouble()，asLong()或asText()。 如果尝试这样做，将会导致NullPointerException。 这是说明这种情况的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">String json = <span class="string">"&#123; \"f1\":\"Hello\" &#125;"</span>;</span><br><span class="line"></span><br><span class="line">JsonNode jsonNode = objectMapper.readTree(json);</span><br><span class="line"></span><br><span class="line">JsonNode f2FieldNode = jsonNode.get(<span class="string">"f2"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="创建一个ObjectNode"><a href="#创建一个ObjectNode" class="headerlink" title="创建一个ObjectNode"></a>创建一个ObjectNode</h3><p>如前所述，JsonNode类是不可变的。 要创建JsonNode对象图，必须能够更改图中的JsonNode实例，例如 设置属性值和子JsonNode实例等。由于是不可变的，因此无法直接使用JsonNode来实现。</p>
<p>而是创建一个ObjectNode实例，该实例是JsonNode的子类。 这是一个通过Jackson ObjectMapper createObjectNode()方法创建ObjectNode的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">ObjectNode objectNode = objectMapper.createObjectNode();</span><br></pre></td></tr></table></figure>

<h3 id="Set-ObjectNode字段"><a href="#Set-ObjectNode字段" class="headerlink" title="Set ObjectNode字段"></a>Set ObjectNode字段</h3><p>要在Jackson ObjectNode上设置字段，可以调用其set()方法，并将字段名称String和JsonNode作为参数传递。 这是在Jackson的ObjectNode上设置字段的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">ObjectNode parentNode = objectMapper.createObjectNode();</span><br><span class="line"></span><br><span class="line">JsonNode childNode = readJsonIntoJsonNode();</span><br><span class="line"></span><br><span class="line">parentNode.set(<span class="string">"child1"</span>, childNode);</span><br></pre></td></tr></table></figure>

<h3 id="Put-ObjectNode字段"><a href="#Put-ObjectNode字段" class="headerlink" title="Put ObjectNode字段"></a>Put ObjectNode字段</h3><p>ObjectNode类还具有一组方法，可以直接为字段put(设置)值。 这比尝试将原始值转换为JsonNode并使用set()进行设置要容易得多。 以下是使用put()方法为ObjectNode上的字段设置字符串值的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">objectNode.put(<span class="string">"field1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">objectNode.put(<span class="string">"field2"</span>, <span class="number">123</span>);</span><br><span class="line">objectNode.put(<span class="string">"field3"</span>, <span class="number">999.999</span>);</span><br></pre></td></tr></table></figure>

<h3 id="删除字段"><a href="#删除字段" class="headerlink" title="删除字段"></a>删除字段</h3><p>ObjectNode类具有一个称为remove()的方法，该方法可用于从ObjectNode中删除字段。 这是一个通过其remove()方法从Jackson ObjectNode删除字段的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objectNode.remove(<span class="string">"fieldName"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="循环JsonNode字段"><a href="#循环JsonNode字段" class="headerlink" title="循环JsonNode字段"></a>循环JsonNode字段</h3><p>JsonNode类具有一个名为fieldNames()的方法，该方法返回一个Iterator，可以迭代JsonNode的所有字段名称。 我们可以使用字段名称来获取字段值。 这是一个迭代Jackson JsonNode的所有字段名称和值的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; fieldNames = jsonNode.fieldNames();</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(fieldNames.hasNext()) &#123;</span><br><span class="line">    String fieldName = fieldNames.next();</span><br><span class="line"></span><br><span class="line">    JsonNode field = jsonNode.get(fieldName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JsonParser"><a href="#JsonParser" class="headerlink" title="JsonParser"></a>JsonParser</h2><p>Jackson JsonParser类是一个底层一些的JSON解析器。 它类似于XML的Java StAX解析器，差别是JsonParser解析JSON而不解析XML。</p>
<p>Jackson JsonParser的运行层级低于Jackson ObjectMapper。 这使得JsonParser比ObjectMapper更快，但使用起来也比较麻烦。</p>
<h3 id="创建一个JsonParser"><a href="#创建一个JsonParser" class="headerlink" title="创建一个JsonParser"></a>创建一个JsonParser</h3><p>为了创建Jackson JsonParser，首先需要创建一个JsonFactory。 JsonFactory用于创建JsonParser实例。 JsonFactory类包含几个createParser()方法，每个方法都使用不同的JSON源作为参数。</p>
<p>这是创建一个JsonParser来从字符串中解析JSON的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String carJson = <span class="string">"&#123; \"brand\" : \"Mercedes\", \"doors\" : 5 &#125;"</span>;</span><br><span class="line"></span><br><span class="line">JsonFactory factory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line">JsonParser  parser  = factory.createParser(carJson);</span><br></pre></td></tr></table></figure>

<h3 id="用JsonParser转化JSON"><a href="#用JsonParser转化JSON" class="headerlink" title="用JsonParser转化JSON"></a>用JsonParser转化JSON</h3><p>一旦创建了Jackson JsonParser，就可以使用它来解析JSON。 JsonParser的工作方式是将JSON分解为一系列令牌，可以一个一个地迭代令牌。</p>
<p>这是一个JsonParser示例，它简单地循环遍历所有标记并将它们输出到System.out。 这是一个实际上很少用示例，只是展示了将JSON分解成的令牌，以及如何遍历令牌的基础知识。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">tring carJson = <span class="string">"&#123; \"brand\" : \"Mercedes\", \"doors\" : 5 &#125;"</span>;</span><br><span class="line"></span><br><span class="line">JsonFactory factory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line">JsonParser  parser  = factory.createParser(carJson);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!parser.isClosed())&#123;</span><br><span class="line">    JsonToken jsonToken = parser.nextToken();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"jsonToken = "</span> + jsonToken);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要JsonParser的isClosed()方法返回false，那么JSON源中仍然会有更多的令牌。</p>
<p>可以使用JsonParser的nextToken()获得一个JsonToken。 您可以使用此JsonToken实例检查给定的令牌。 令牌类型由JsonToken类中的一组常量表示。 这些常量是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">START_OBJECT</span><br><span class="line">END_OBJECT</span><br><span class="line">START_ARRAY</span><br><span class="line">END_ARRAY</span><br><span class="line">FIELD_NAME</span><br><span class="line">VALUE_EMBEDDED_OBJECT</span><br><span class="line">VALUE_FALSE</span><br><span class="line">VALUE_TRUE</span><br><span class="line">VALUE_NULL</span><br><span class="line">VALUE_STRING</span><br><span class="line">VALUE_NUMBER_INT</span><br><span class="line">VALUE_NUMBER_FLOAT</span><br></pre></td></tr></table></figure>

<p>可以使用这些常量来找出当前JsonToken是什么类型的令牌。 可以通过这些常量的equals()方法进行操作。 这是一个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">String carJson = <span class="string">"&#123; \"brand\" : \"Mercedes\", \"doors\" : 5 &#125;"</span>;</span><br><span class="line"></span><br><span class="line">JsonFactory factory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line">JsonParser  parser  = factory.createParser(carJson);</span><br><span class="line"></span><br><span class="line">Car car = <span class="keyword">new</span> Car();</span><br><span class="line"><span class="keyword">while</span>(!parser.isClosed())&#123;</span><br><span class="line">    JsonToken jsonToken = parser.nextToken();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(JsonToken.FIELD_NAME.equals(jsonToken))&#123;</span><br><span class="line">        String fieldName = parser.getCurrentName();</span><br><span class="line">        System.out.println(fieldName);</span><br><span class="line"></span><br><span class="line">        jsonToken = parser.nextToken();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"brand"</span>.equals(fieldName))&#123;</span><br><span class="line">            car.brand = parser.getValueAsString();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"doors"</span>.equals(fieldName))&#123;</span><br><span class="line">            car.doors = parser.getValueAsInt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"car.brand = "</span> + car.brand);</span><br><span class="line">System.out.println(<span class="string">"car.doors = "</span> + car.doors);</span><br></pre></td></tr></table></figure>

<p>如果指向的标记是字段名称，则JsonParser的getCurrentName()方法将返回当前字段名称。</p>
<p>如果指向的令牌是字符串字段值，则getValueAsString()返回当前令牌值作为字符串。 如果指向的令牌是整数字段值，则getValueAsInt()返回当前令牌值作为int值。 JsonParser具有更多类似的方法来获取不同类型的curren令牌值（例如boolean，short，long，float，double等）。</p>
<h2 id="JsonGenerator"><a href="#JsonGenerator" class="headerlink" title="JsonGenerator"></a>JsonGenerator</h2><p>Jackson JsonGenerator用于从Java对象（或代码从中生成JSON的任何数据结构）生成JSON。</p>
<h3 id="创建一个JsonGenerator"><a href="#创建一个JsonGenerator" class="headerlink" title="创建一个JsonGenerator"></a>创建一个JsonGenerator</h3><p>为了创建Jackson JsonGenerator，必须首先创建JsonFactory实例。 这是创建JsonFactory的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JsonFactory factory = <span class="keyword">new</span> JsonFactory();</span><br></pre></td></tr></table></figure>

<p>一旦创建了JsonFactory，就可以使用JsonFactory的createGenerator()方法创建JsonGenerator。 这是创建JsonGenerator的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JsonFactory factory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line"></span><br><span class="line">JsonGenerator generator = factory.createGenerator(</span><br><span class="line">    <span class="keyword">new</span> File(<span class="string">"data/output.json"</span>), JsonEncoding.UTF8);</span><br></pre></td></tr></table></figure>

<p>createGenerator()方法的第一个参数是生成的JSON的目标。 在上面的示例中，参数是File对象。 这意味着生成的JSON将被写入给定文件。 createGenerator()方法已重载，因此还有其他版本的createGenerator()方法采用例如OutputStream等，提供了有关将生成的JSON写入何处的不同选项。</p>
<p>createGenerator()方法的第二个参数是生成JSON时使用的字符编码。上面的示例使用UTF-8。</p>
<h3 id="使用JsonGenerator生成JSON"><a href="#使用JsonGenerator生成JSON" class="headerlink" title="使用JsonGenerator生成JSON"></a>使用JsonGenerator生成JSON</h3><p>一旦创建了JsonGenerator，就可以开始生成JSON。 JsonGenerator包含一组write …()方法，可以使用这些方法来编写JSON对象的各个部分。 这是一个使用Jackson JsonGenerator生成JSON的简单示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">JsonFactory factory = <span class="keyword">new</span> JsonFactory();</span><br><span class="line"></span><br><span class="line">JsonGenerator generator = factory.createGenerator(</span><br><span class="line">    <span class="keyword">new</span> File(<span class="string">"data/output.json"</span>), JsonEncoding.UTF8);</span><br><span class="line"></span><br><span class="line">generator.writeStartObject();</span><br><span class="line">generator.writeStringField(<span class="string">"brand"</span>, <span class="string">"Mercedes"</span>);</span><br><span class="line">generator.writeNumberField(<span class="string">"doors"</span>, <span class="number">5</span>);</span><br><span class="line">generator.writeEndObject();</span><br><span class="line"></span><br><span class="line">generator.close();</span><br></pre></td></tr></table></figure>

<p>此示例首先调用writeStartObject()，将{写入输出。 然后，该示例调用writeStringField()，将品牌字段名称+值写入输出。 之后，将调用writeNumberField()方法，此方法会将Doors字段名称+值写入输出。 最后，调用writeEndObject()，将}写入输出。</p>
<p>JsonGenerator还可以使用许多其他写入方法。 这个例子只显示了其中一些。</p>
<h3 id="关闭JsonGenerator"><a href="#关闭JsonGenerator" class="headerlink" title="关闭JsonGenerator"></a>关闭JsonGenerator</h3><p>完成生成JSON后，应关闭JsonGenerator。 您可以通过调用其close()方法来实现。 这是关闭JsonGenerator的样子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">generator.close();</span><br></pre></td></tr></table></figure>

<h2 id="Jackson注解"><a href="#Jackson注解" class="headerlink" title="Jackson注解"></a>Jackson注解</h2><p>Jackson JSON工具包包含一组Java注解，可以使用这些注解来设置将JSON读入对象的方式或从对象生成什么JSON的方式。 此Jackson注解教程介绍了如何使用Jackson的注解。</p>
<p>下面是一些常用的注解：</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>用法</th>
</tr>
</thead>
<tbody><tr>
<td>@JsonProperty</td>
<td>用于属性，把属性的名称序列化时转换为另外一个名称。示例：   @JsonProperty(“birth_ d                            ate”)   private Date birthDate;</td>
</tr>
<tr>
<td>@JsonFormat</td>
<td>用于属性或者方法，把属性的格式序列化时转换成指定的格式。示例：   @JsonFormat(timezone =                            “GMT+8”, pattern = “yyyy-MM-dd HH:mm”)   public Date                            getBirthDate()</td>
</tr>
<tr>
<td>@JsonPropertyOrder</td>
<td>用于类， 指定属性在序列化时 json 中的顺序 ， 示例：   @JsonPropertyOrder({                            “birth_Date”, “name” })   public class Person</td>
</tr>
<tr>
<td>@JsonCreator</td>
<td>用于构造方法，和 @JsonProperty 配合使用，适用有参数的构造方法。 示例：                              @JsonCreator   public Person(@JsonProperty(“name”)String                            name) {…}</td>
</tr>
<tr>
<td>@JsonAnySetter</td>
<td>用于属性或者方法，设置未反序列化的属性名和值作为键值存储到 map 中   @JsonAnySetter                              public void set(String key, Object value) {                              map.put(key, value);   }</td>
</tr>
<tr>
<td>@JsonAnyGetter</td>
<td>用于方法 ，获取所有未序列化的属性   <code>public Map&lt;String, Object&gt;                            any() { return map; }</code></td>
</tr>
</tbody></table>
<p>下面是一些注解的详细说明。</p>
<h3 id="Read-Write注解"><a href="#Read-Write注解" class="headerlink" title="Read + Write注解"></a>Read + Write注解</h3><p>Jackson包含一组注解，这些注解会影响从JSON读取Java对象以及将Java对象写入JSON。 我将这些注解称为“读+写注解”。 以下各节将更详细地介绍Jackson的读写注解。</p>
<h4 id="JsonIgnore"><a href="#JsonIgnore" class="headerlink" title="@JsonIgnore"></a>@JsonIgnore</h4><p>Jackson注解@JsonIgnore用于告诉Jackson忽略Java对象的某个属性（字段）。 在将JSON读取到Java对象中以及将Java对象写入JSON时，都将忽略该属性。</p>
<p>这是使用@JsonIgnore注解的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonIgnore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonIgnore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonIgnore</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span>  personId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的类中，不会从JSON读取或写入JSON属性personId。</p>
<h4 id="JsonIgnoreProperties"><a href="#JsonIgnoreProperties" class="headerlink" title="@JsonIgnoreProperties"></a>@JsonIgnoreProperties</h4><p>@JsonIgnoreProperties Jackson注解用于指定要忽略的类的属性列表。 @JsonIgnoreProperties注解放置在类声明上方，而不是要忽略的各个属性（字段）上方。</p>
<p>这是如何使用@JsonIgnoreProperties注解的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonIgnoreProperties;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JsonIgnoreProperties</span>(&#123;<span class="string">"firstName"</span>, <span class="string">"lastName"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonIgnoreProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span>   personId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String  firstName = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> String  lastName  = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此示例中，属性firstName和lastName都将被忽略，因为它们的名称在类声明上方的@JsonIgnoreProperties注解声明内列出。</p>
<h4 id="JsonIgnoreType"><a href="#JsonIgnoreType" class="headerlink" title="@JsonIgnoreType"></a>@JsonIgnoreType</h4><p>@JsonIgnoreType Jackson注解用于将整个类型（类）标记为在使用该类型的任何地方都将被忽略。</p>
<p>这是一个示例，展示如何使用@JsonIgnoreType注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonIgnoreType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonIgnoreType</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonIgnoreType</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> String streetName  = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">public</span> String houseNumber = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">public</span> String zipCode     = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">public</span> String city        = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">public</span> String country     = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span>    personId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String  name = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Address address = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的示例中，所有Address实例将被忽略。</p>
<h3 id="JsonAutoDetect"><a href="#JsonAutoDetect" class="headerlink" title="@JsonAutoDetect"></a>@JsonAutoDetect</h3><p>Jackson注解@JsonAutoDetect用于告诉Jackson在读写对象时包括非public修饰的属性。</p>
<p>这是一个示例类，展示如何使用@JsonAutoDetect注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonAutoDetect;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JsonAutoDetect</span>(fieldVisibility = JsonAutoDetect.Visibility.ANY )</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonAutoDetect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span>  personId = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">public</span> String name     = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JsonAutoDetect.Visibility类包含与Java中的可见性级别匹配的常量，表示ANY，DEFAULT，NON_PRIVATE，NONE，PROTECTED_AND_PRIVATE和PUBLIC_ONLY。</p>
<h3 id="Read注解"><a href="#Read注解" class="headerlink" title="Read注解"></a>Read注解</h3><p>Jackson包含一组注解，这些注解仅影响Jackson将JSON解析为对象的方式-意味着它们影响Jackson对JSON的读取。 我称这些为“读注解”。 以下各节介绍了Jackson的读注解。</p>
<h4 id="JsonSetter"><a href="#JsonSetter" class="headerlink" title="@JsonSetter"></a>@JsonSetter</h4><p>Jackson注解@JsonSetter用于告诉Jackson，当将JSON读入对象时，应将此setter方法的名称与JSON数据中的属性名称匹配。 如果Java类内部使用的属性名称与JSON文件中使用的属性名称不同，这个注解就很有用了。</p>
<p>以下Person类用personId名称对应JSON中名为id的字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span>   personId = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> String name     = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getPersonId</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.personId; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPersonId</span><span class="params">(<span class="keyword">long</span> personId)</span> </span>&#123; <span class="keyword">this</span>.personId = personId; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是在此JSON对象中，使用名称id代替personId：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"id"</span>   : <span class="number">1234</span>,</span><br><span class="line">  <span class="attr">"name"</span> : <span class="string">"John"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Jackson无法将id属性从JSON对象映射到Java类的personId字段。</p>
<p>@JsonSetter注解指示Jackson为给定的JSON字段使用setter方法。 在我们的示例中，我们在setPersonId()方法上方添加@JsonSetter注解。</p>
<p>这是添加@JsonSetter注解的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span>   personId = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> String name     = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getPersonId</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.personId; &#125;</span><br><span class="line">    <span class="meta">@JsonSetter</span>(<span class="string">"id"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPersonId</span><span class="params">(<span class="keyword">long</span> personId)</span> </span>&#123; <span class="keyword">this</span>.personId = personId; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@JsonSetter注解中指定的值是要与此setter方法匹配的JSON字段的名称。 在这种情况下，名称为id，因为这是我们要映射到setPersonId()setter方法的JSON对象中字段的名称。</p>
<h4 id="JsonAnySetter"><a href="#JsonAnySetter" class="headerlink" title="@JsonAnySetter"></a>@JsonAnySetter</h4><p>Jackson注解@JsonAnySetter表示Jackson为JSON对象中所有无法识别的字段调用相同的setter方法。 “无法识别”是指尚未映射到Java对象中的属性或设置方法的所有字段。</p>
<p>看一下这个Bag类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bag</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; properties = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String fieldName, Object value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.properties.put(fieldName, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String fieldName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.properties.get(fieldName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后查看此JSON对象：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"id"</span>   : <span class="number">1234</span>,</span><br><span class="line">  <span class="attr">"name"</span> : <span class="string">"John"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Jackson无法直接将此JSON对象的id和name属性映射到Bag类，因为Bag类不包含任何公共字段或setter方法。</p>
<p>可以通过添加@JsonAnySetter注解来告诉Jackson为所有无法识别的字段调用set()方法，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bag</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; properties = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonAnySetter</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(String fieldName, Object value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.properties.put(fieldName, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(String fieldName)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.properties.get(fieldName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，Jackson将使用JSON对象中所有无法识别的字段的名称和值调用set()方法。</p>
<p>请记住，这仅对无法识别的字段有效。 例如，如果您向Bag Java类添加了公共名称属性或setName（String）方法，则JSON对象中的名称字段将改为映射到该属性/设置器。</p>
<h4 id="JsonCreator"><a href="#JsonCreator" class="headerlink" title="@JsonCreator"></a>@JsonCreator</h4><p>Jackson注解@JsonCreator用于告诉Jackson该Java对象具有一个构造函数（“创建者”），该构造函数可以将JSON对象的字段与Java对象的字段进行匹配。</p>
<p>@JsonCreator注解在无法使用@JsonSetter注解的情况下很有用。 例如，不可变对象没有任何设置方法，因此它们需要将其初始值注入到构造函数中。</p>
<p>以这个PersonImmutable类为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonImmutable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span>   id   = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonImmutable</span><span class="params">(<span class="keyword">long</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要告诉Jackson应该调用PersonImmutable的构造函数，我们必须在构造函数中添加@JsonCreator注解。 但是，仅凭这一点还不够。 我们还必须注解构造函数的参数，以告诉Jackson将JSON对象中的哪些字段传递给哪些构造函数参数。</p>
<p>添加了@JsonCreator和@JsonProperty注解的PersonImmutable类的示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonImmutable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span>   id   = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonCreator</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PersonImmutable</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            @JsonProperty(<span class="string">"id"</span>)</span>  <span class="keyword">long</span> id,</span></span><br><span class="line"><span class="function">            @<span class="title">JsonProperty</span><span class="params">(<span class="string">"name"</span>)</span> String name  ) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，构造函数上方的注解以及构造函数参数之前的注解。 现在，Jackson能够从此JSON对象创建PersonImmutable：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"id"</span>   : <span class="number">1234</span>,</span><br><span class="line">  <span class="attr">"name"</span> : <span class="string">"John"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="JacksonInject"><a href="#JacksonInject" class="headerlink" title="@JacksonInject"></a>@JacksonInject</h4><p>Jackson注解@JacksonInject用于将值注入到解析的对象中，而不是从JSON中读取这些值。 例如，假设正在从各种不同的源下载Person JSON对象，并且想知道给定Person对象来自哪个源。 源本身可能不包含该信息，但是可以让Jackson将其注入到根据JSON对象创建的Java对象中。</p>
<p>要将Java类中的字段标记为需要由Jackson注入其值的字段，请在该字段上方添加@JacksonInject注解。</p>
<p>这是一个示例PersonInject类，在属性上方添加了@JacksonInject注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonInject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span>   id   = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> String name = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JacksonInject</span></span><br><span class="line">    <span class="keyword">public</span> String source = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>为了让Jackson将值注入属性，需要在创建Jackson ObjectMapper时做一些额外的工作。</p>
<p>这是让Jackson将值注入Java对象的过程：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InjectableValues inject = new InjectableValues.Std().addValue(String.class, "jenkov.com");</span><br><span class="line">PersonInject personInject = <span class="keyword">new</span> ObjectMapper().reader(inject)</span><br><span class="line">                        .forType(PersonInject<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">                        .readValue(new File("data/person.json"));</span><br></pre></td></tr></table></figure>

<p>请注意，如何在InjectableValues addValue()方法中设置要注入到source属性中的值。 还要注意，该值仅绑定到字符串类型-而不绑定到任何特定的字段名称。 @JacksonInject注解指定将值注入到哪个字段。</p>
<p>如果要从多个源下载人员JSON对象，并为每个源注入不同的源值，则必须为每个源重复以上代码。</p>
<h4 id="JsonDeserialize"><a href="#JsonDeserialize" class="headerlink" title="@JsonDeserialize"></a>@JsonDeserialize</h4><p>Jackson注解@JsonDeserialize用于为Java对象中给定的属性指定自定义反序列化器类。<br>例如，假设想优化布尔值false和true的在线格式，使其分别为0和1。</p>
<p>首先，需要将@JsonDeserialize注解添加到要为其使用自定义反序列化器的字段。 这是将@JsonDeserialize注解添加到字段的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDeserialize</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span>    id      = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> String  name    = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonDeserialize</span>(using = OptimizedBooleanDeserializer<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">boolean</span> <span class="title">enabled</span> </span>= <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其次，这是@JsonDeserialize注解中引用的OptimizedBooleanDeserializer类的实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptimizedBooleanDeserializer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">JsonDeserializer</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">deserialize</span><span class="params">(JsonParser jsonParser,</span></span></span><br><span class="line"><span class="function"><span class="params">            DeserializationContext deserializationContext)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">        IOException, JsonProcessingException </span>&#123;</span><br><span class="line"></span><br><span class="line">        String text = jsonParser.getText();</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"0"</span>.equals(text)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，OptimizedBooleanDeserializer类使用通用类型Boolean扩展了JsonDeserializer。 这样做会使deserialize()方法返回一个布尔对象。 如果要反序列化其他类型（例如java.util.Date），则必须在泛型括号内指定该类型。</p>
<p>可以通过调用jsonParser参数的getText()方法来获取要反序列化的字段的值。 然后，可以将该文本反序列化为任何值，然后输入反序列化程序所针对的类型（在此示例中为布尔值）。</p>
<p>最后，需要查看使用自定义反序列化器和@JsonDeserializer注解反序列化对象的格式：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PersonDeserialize person = objectMapper</span><br><span class="line">        .reader(PersonDeserialize<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">        .readValue(new File("data/person-optimized-boolean.json"));</span><br></pre></td></tr></table></figure>

<p>注意，我们首先需要如何使用ObjectMapper的reader()方法为PersonDeserialize类创建一个阅读器，然后在该方法返回的对象上调用readValue()。</p>
<h3 id="Write注解"><a href="#Write注解" class="headerlink" title="Write注解"></a>Write注解</h3><p>Jackson还包含一组注解，这些注解可以影响Jackson将Java对象序列化（写入）到JSON的方式。 以下各节将介绍这些写（序列化）注解中的每一个。</p>
<h4 id="JsonInclude"><a href="#JsonInclude" class="headerlink" title="@JsonInclude"></a>@JsonInclude</h4><p>Jackson注解@JsonInclude告诉Jackson仅在某些情况下包括属性。 例如，仅当属性为非null，非空或具有非默认值时，才应包括该属性。 这是显示如何使用@JsonInclude注解的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.annotation.JsonInclude;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JsonInclude</span>(JsonInclude.Include.NON_EMPTY)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonInclude</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span>  personId = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> String name     = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果为该示例设置的值是非空的，则此示例将仅包括name属性，这意味着不为null且不是空字符串。</p>
<p>@JsonInclude注解的一个更通俗的名称应该是@JsonIncludeOnlyWhen，但是写起来会更长。</p>
<h4 id="JsonGetter"><a href="#JsonGetter" class="headerlink" title="@JsonGetter"></a>@JsonGetter</h4><p>@JsonGetter Jackson注解用于告诉Jackson，应该通过调用getter方法而不是通过直接字段访问来获取某个字段值。 如果您的Java类使用jQuery样式的getter和setter名称，则@JsonGetter注解很有用。</p>
<p>例如，您可能拥有方法personId()和personId（long id），而不是getPersonId()和setPersonId()。</p>
<p>这是一个名为PersonGetter的示例类，它显示了@JsonGetter注解的用法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonGetter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span>  personId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonGetter</span>(<span class="string">"id"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">personId</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.personId; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonSetter</span>(<span class="string">"id"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">personId</span><span class="params">(<span class="keyword">long</span> personId)</span> </span>&#123; <span class="keyword">this</span>.personId = personId; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如您所见，personId()方法带有@JsonGetter注解。 @JsonGetter注解上设置的值是JSON对象中应使用的名称。 因此，用于JSON对象中personId的名称是id。 生成的JSON对象如下所示：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"id"</span>:<span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure>

<p>还要注意，personId（long personId）方法使用@JsonSetter注解进行注解，以使Jackson识别为与JSON对象中的id属性匹配的设置方法。 从JSON读取Java对象时使用@JsonSetter注解-将Java对象写入JSON时不使用。 为了完整起见，仅包含@JsonSetter注解。</p>
<h4 id="JsonAnyGetter"><a href="#JsonAnyGetter" class="headerlink" title="@JsonAnyGetter"></a>@JsonAnyGetter</h4><p>@JsonAnyGetter Jackson注解使您可以将Map用作要序列化为JSON的属性的容器。 这是在Java类中使用@JsonAnyGetter注解的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonAnyGetter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; properties = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonAnyGetter</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">properties</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> properties;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当看到@JsonAnyGetter注解时，Jackson将从@JsonAnyGetter注解的方法中获取返回的Map，并将该Map中的每个键值对都视为一个属性。 换句话说，Map中的所有键值对都将作为PersonAnyGetter对象的一部分序列化为JSON。</p>
<h4 id="JsonPropertyOrder"><a href="#JsonPropertyOrder" class="headerlink" title="@JsonPropertyOrder"></a>@JsonPropertyOrder</h4><p>@JsonPropertyOrder Jackson注解可用于指定将Java对象的字段序列化为JSON的顺序。 这是显示如何使用@JsonPropertyOrder注解的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonPropertyOrder</span>(&#123;<span class="string">"name"</span>, <span class="string">"personId"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonPropertyOrder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span>  personId  = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> String name     = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通常，Jackson会按照在类中找到的顺序序列化PersonPropertyOrder中的属性。 但是，@JsonPropertyOrder注解指定了不同的顺序，在序列化的JSON输出中，name属性将首先出现，personId属性将随后出现。</p>
<h4 id="JsonRawValue"><a href="#JsonRawValue" class="headerlink" title="@JsonRawValue"></a>@JsonRawValue</h4><p>@JsonRawValue Jackson注解告诉Jackson该属性值应直接写入JSON输出。 如果该属性是字符串，Jackson通常会将值括在引号中，但是如果使用@JsonRawValue属性进行注解，Jackson将不会这样做。</p>
<p>为了更清楚@JsonRawValue的作用，看看没有使用@JsonRawValue的此类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonRawValue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span>   personId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String address  = <span class="string">"$#"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Jackson会将其序列化为以下JSON字符串：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"personId"</span>:<span class="number">0</span>,<span class="attr">"address"</span>:<span class="string">"$#"</span>&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们将@JsonRawValue添加到address属性，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonRawValue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span>   personId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonRawValue</span></span><br><span class="line">    <span class="keyword">public</span> String address  = <span class="string">"$#"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，当对地址属性进行序列化时，杰克逊将省略引号。 因此，序列化的JSON如下所示：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"personId"</span>:<span class="number">0</span>,<span class="attr">"address"</span>:$#&#125;</span><br></pre></td></tr></table></figure>

<p>当然它是无效的JSON，那么为什么要这么做呢？</p>
<p>如果address属性包含一个JSON字符串，那么该JSON字符串将被序列化为最终的JSON对象，作为JSON对象结构的一部分，而不仅是序列化为JSON对象的address字段中的字符串。<br>要查看其工作原理，让我们像下面这样更改address属性的值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonRawValue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span>   personId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonRawValue</span></span><br><span class="line">    <span class="keyword">public</span> String address  =</span><br><span class="line">            <span class="string">"&#123; \"street\" : \"Wall Street\", \"no\":1&#125;"</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Jackson会将其序列化为以下JSON：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"personId"</span>:<span class="number">0</span>,<span class="attr">"address"</span>:&#123; <span class="attr">"street"</span> : <span class="string">"Wall Street"</span>, <span class="attr">"no"</span>:<span class="number">1</span>&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，JSON字符串现在如何成为序列化JSON结构的一部分。</p>
<p>没有@JsonRawValue注解，Jackson会将对象序列化为以下JSON：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"personId"</span>:<span class="number">0</span>,<span class="attr">"address"</span>:<span class="string">"&#123; \"street\" : \"Wall Street\", \"no\":1&#125;"</span>&#125;</span><br></pre></td></tr></table></figure>

<p>请注意，address属性的值现在如何用引号引起来，并且值内的所有引号均被转义。</p>
<h4 id="JsonValue"><a href="#JsonValue" class="headerlink" title="@JsonValue"></a>@JsonValue</h4><p>Jackson注解@JsonValue告诉Jackson，Jackson不应该尝试序列化对象本身，而应在对象上调用将对象序列化为JSON字符串的方法。 请注意，Jackson将在自定义序列化返回的String内转义任何引号，因此不能返回例如 完整的JSON对象。 为此，应该改用@JsonRawValue（请参阅上一节）。</p>
<p>@JsonValue注解已添加到Jackson调用的方法中，以将对象序列化为JSON字符串。 这是显示如何使用@JsonValue注解的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonValue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span>   personId = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> String name = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonValue</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toJson</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.personId + <span class="string">","</span> + <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要求Jackson序列化PersonValue对象所得到的输出是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"0,null"</span></span><br></pre></td></tr></table></figure>

<p>引号由Jackson添加。 请记住，对象返回的值字符串中的所有引号均会转义。</p>
<h4 id="JsonSerialize"><a href="#JsonSerialize" class="headerlink" title="@JsonSerialize"></a>@JsonSerialize</h4><p>@JsonSerialize Jackson注解用于为Java对象中的字段指定自定义序列化程序。 这是一个使用@JsonSerialize注解的Java类示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonSerializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 long 序列化为 String，解决返回前端JS数值精度丢失问题</span></span><br><span class="line">    <span class="meta">@JsonSerialize</span>(using = ToStringSerializer<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">long</span>   <span class="title">personId</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name     = <span class="string">"John"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JsonSerialize</span>(using = OptimizedBooleanSerializer<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">boolean</span> <span class="title">enabled</span> </span>= <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意启用字段上方的@JsonSerialize注解。</p>
<p>OptimizedBooleanSerializer将序列的真值序列化为1，将假值序列化为0。这是代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OptimizedBooleanSerializer</span> <span class="keyword">extends</span> <span class="title">JsonSerializer</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serialize</span><span class="params">(Boolean aBoolean, JsonGenerator jsonGenerator, </span></span></span><br><span class="line"><span class="function"><span class="params">        SerializerProvider serializerProvider)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, JsonProcessingException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(aBoolean)&#123;</span><br><span class="line">            jsonGenerator.writeNumber(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            jsonGenerator.writeNumber(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JsonTypeInfo-多态类型"><a href="#JsonTypeInfo-多态类型" class="headerlink" title="@JsonTypeInfo 多态类型"></a>@JsonTypeInfo 多态类型</h3><p>Jackson框架对json字段的序列化和反序列化默认策略是根据getter和setter方法，去掉get和set,再把首字母小写，便找到了对应的字段。通常情况，我们都是对普通的POJO进行serialization/deserialization。那么如果遇到了解析抽象类(或者接口)呢？如何定位到对应的实现类？实现类都找不到，谈何匹配到对应的字段反序列化。</p>
<p>jackson允许配置多态类型处理，当进行反序列话时，JSON数据匹配的对象可能有多个子类型，为了正确的读取对象的类型，我们需要添加一些类型信息。可以通过下面几个注解来实现：</p>
<ul>
<li><p>@JsonTypeInfo</p>
<ul>
<li>作用于类/接口，被用来开启多态类型处理，对基类/接口和子类/实现类都有效</li>
<li><code>@JsonTypeInfo(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = &quot;name&quot;)</code></li>
</ul>
</li>
<li><p>这个注解有一些属性:</p>
<ul>
<li>use:定义使用哪一种类型识别码，它有下面几个可选值：<ul>
<li><code>JsonTypeInfo.Id.CLASS</code>：使用完全限定类名做识别, (使用class name会使代码的可移植性变差。比如代码修改包名后，再按照json里的metadata反序列化，发现找不到类了)</li>
<li><code>JsonTypeInfo.Id.MINIMAL_CLASS</code>：若基类和子类在同一包类，使用类名(忽略包名)作为识别码</li>
<li><code>JsonTypeInfo.Id.NAME</code>：一个合乎逻辑的指定名称</li>
<li><code>JsonTypeInfo.Id.CUSTOM</code>：自定义识别码，由<code>@JsonTypeIdResolver</code>对应，稍后解释</li>
<li><code>JsonTypeInfo.Id.NONE</code>：不使用识别码</li>
</ul>
</li>
<li>include(可选):指定识别码是如何被包含进去的，它有下面几个可选值：<ul>
<li>JsonTypeInfo.As.PROPERTY：作为数据的兄弟属性</li>
<li>JsonTypeInfo.As.EXISTING_PROPERTY：作为POJO中已经存在的属性</li>
<li>JsonTypeInfo.As.EXTERNAL_PROPERTY：作为扩展属性</li>
<li>JsonTypeInfo.As.WRAPPER_OBJECT：作为一个包装的对象</li>
<li>JsonTypeInfo.As.WRAPPER_ARRAY：作为一个包装的数组</li>
</ul>
</li>
<li>property(可选):制定识别码的属性名称, 此属性只有当:<ul>
<li><code>use为JsonTypeInfo.Id.CLASS</code>（若不指定property则默认为@class）、<code>JsonTypeInfo.Id.MINIMAL_CLASS</code>(若不指定property则默认为@c)、<code>JsonTypeInfo.Id.NAME</code>(若不指定property默认为@type)</li>
<li><code>include为JsonTypeInfo.As.PROPERTY</code>、<code>JsonTypeInfo.As.EXISTING_PROPERTY</code>、<code>JsonTypeInfo.As.EXTERNAL_PROPERTY</code>时才有效</li>
</ul>
</li>
<li>defaultImpl(可选)：如果类型识别码不存在或者无效，可以使用该属性来制定反序列化时使用的默认类型</li>
<li>visible(可选，默认为false)：是否可见属性定义了类型标识符的值是否会通过JSON流成为反序列化器的一部分，默认为fale,也就是说,jackson会从JSON内容中处理和删除类型标识符再传递给JsonDeserializer。</li>
</ul>
</li>
<li><p>@JsonSubTypes</p>
<ul>
<li>作用于类/接口，用来列出给定类的子类，只有当子类类型无法被检测到时才会使用它,一般是配合@JsonTypeInfo在基类上使用</li>
<li>它的Type子类有两个属性，可以定义一个类的别名：<ul>
<li>value：给哪个子类起名字</li>
<li>name：起啥名字</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>基本使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonTypeInfo</span>(use = JsonTypeInfo.Id.NAME, include = JsonTypeInfo.As.PROPERTY, property = <span class="string">"custom-type-name"</span>)</span><br><span class="line"><span class="meta">@JsonSubTypes</span>(value = &#123;</span><br><span class="line">    <span class="meta">@JsonSubTypes</span>.Type(value = Son1<span class="class">.<span class="keyword">class</span>, <span class="title">name</span> </span>= <span class="string">"FirstSon"</span>),</span><br><span class="line">    <span class="meta">@JsonSubTypes</span>.Type(value = Son2<span class="class">.<span class="keyword">class</span>, <span class="title">name</span> </span>= <span class="string">"SecondSon"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">xxx</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or public abstract class AbstractXXX &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<p>生成如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"list"</span>:[&#123;<span class="attr">"custom-type-name"</span>:<span class="string">"SecondSon"</span>,<span class="attr">"a"</span>:<span class="number">5</span>,<span class="attr">"c"</span>:<span class="string">"10"</span>&#125;,&#123;<span class="attr">"custom-type-name"</span>:<span class="string">"FirstSon"</span>,<span class="attr">"a"</span>:<span class="number">5</span>,<span class="attr">"b"</span>:<span class="number">0</span>&#125;]&#125;</span><br></pre></td></tr></table></figure>

<p><strong>必须记录的多态类型</strong></p>
<p>从json的角度来看，就好像是对象除了a、c，还有一个custom-type-name属性一样。如果直接看json，这种新增了metadata的行为岂不是会让人产生误会？</p>
<p>先反过来想，如果不加metadata会怎样？</p>
<p>不加多态信息也能直接序列化，且不带metadata：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"list"</span>:[&#123;<span class="attr">"a"</span>:<span class="number">5</span>,<span class="attr">"c"</span>:<span class="string">"10"</span>&#125;,&#123;<span class="attr">"a"</span>:<span class="number">5</span>,<span class="attr">"b"</span>:<span class="number">0</span>&#125;]&#125;</span><br></pre></td></tr></table></figure>

<p>这的确是原汁原味的对象内容！但是反序列化的时候，发现反序列化不回来了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread "main" com.fasterxml.jackson.databind.exc.UnrecognizedPropertyException: Unrecognized field "c" (class example.jackson.Family$Father), not marked as ignorable (one known property: "a"])</span><br><span class="line"> at [Source: (String)<span class="string">"&#123;"</span>list<span class="string">":[&#123;"</span>a<span class="string">":5,"</span>c<span class="string">":"</span><span class="number">10</span><span class="string">"&#125;,&#123;"</span>a<span class="string">":5,"</span>b<span class="string">":0&#125;]&#125;"</span>; line: <span class="number">1</span>, column: <span class="number">22</span>] (through reference chain: example.jackson.Family$D[<span class="string">"list"</span>]-&gt;java.util.ArrayList[<span class="number">0</span>]-&gt;example.jackson.Family$Father[<span class="string">"c"</span>])</span><br></pre></td></tr></table></figure>

<p>因为序列化的时候记录的信息不足，导致不知道究竟是哪个子类。</p>
<p>所以说，这个类型信息是必须被记录的，不管使用<code>@autotype</code>还是以普通property的形式去记录，总之都要记下来，然后用相对应的处理metadata的反序列化方法将json反序列化为对象。</p>
<p>但是这样序列化出来的json看起来会比较奇怪，总感觉不是“纯正的json”。json的好处就是可读，这么搞可读性稍稍下降了一些。json序列化框架使用了一种略微影响可读性的方式完成了对多态的序列化。</p>
<p>其他序列化方式（比如protobuf、avro）呢？可想而知，因为他们本身就是序列化为字节，不是给人看的，人们也不关心他们写了啥字节，他们自然想写啥写啥。比如protobuf可以用oneof指代一个field，至于这个field是Son1还是Son2，肯定通过字节标识出来了，要不然protobuf也是不可能发序列化回来的。</p>
<p>所以说，只要人类看不见，就不会逼逼赖赖了:D</p>
<p>说到这里，不禁想到了Java多态的本身：运行时，如果一个Son1赋值给Father的引用，理论上来讲只知道这是一个Father对象，实际上它可能是Son1也可能是Son2，那么调用具体的方法时，为什么Java能准确地调用Son1的override方法呢？</p>
<p>根据上面序列化的经验，可以猜想Java一定像json序列化一样，将子类型也记录了下来，才能在调用的时候找到真正的子类型：</p>
<ol>
<li>每个.class字节码文件在被ClassLoader加载之后都会在jvm中生成一个唯一的Class对象，该Class类型的对象含有该类的所有信息，比如类名、方法、field、构造函数等；</li>
<li>每一个该类new出来的对象，都有一个指向上述Class对象的引用。可通过Object的<code>public final native Class&lt;?&gt; getClass()</code>方法获得Class对象；</li>
<li>获取到了一个object的Class对象之后，关于这个object的一切类相关的信息都可以通过Class对象取得了。</li>
</ol>
<blockquote>
<p>这不是多态的实际实现，但说明了一个对象的实际类型实际上都是可以被检索到的。</p>
</blockquote>
<p>所以Java也是通过记录所有对象的类信息，以在运行时实时决定该对象类型，并在多态时调用合适的override方法。</p>
<p><strong>因此，解决多态问题的唯一途径就是记录下该对象究竟是哪一个子类型，无论是序列化时的多态还是运行时的多态！</strong></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://juejin.cn/post/6844904166809157639" target="_blank" rel="noopener">Jackson使用详解</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/jackson-advanced-application/index.html" target="_blank" rel="noopener">Jackson 框架的高阶应用</a></li>
<li><a href="http://tutorials.jenkov.com/java-json/jackson-objectmapper.html#jackson-databind" target="_blank" rel="noopener">Jackson Installation</a></li>
<li><a href="http://tutorials.jenkov.com/java-json/jackson-installation.html" target="_blank" rel="noopener">Jackson ObjectMapper</a></li>
<li><a href="http://tutorials.jenkov.com/java-json/jackson-jsonnode.html" target="_blank" rel="noopener">Jackson JsonNode</a></li>
<li><a href="http://tutorials.jenkov.com/java-json/jackson-jsonparser.html" target="_blank" rel="noopener">Jackson JsonParser</a></li>
<li><a href="http://tutorials.jenkov.com/java-json/jackson-jsongenerator.html" target="_blank" rel="noopener">Jackson JsonGenerator</a></li>
<li><a href="http://tutorials.jenkov.com/java-json/jackson-annotations.html" target="_blank" rel="noopener">Jackson Annotations</a></li>
<li><a href="https://www.baeldung.com/jackson-annotations" target="_blank" rel="noopener">Jackson Annotation Examples</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Spring/" rel="tag"># Spring</a>
              <a href="/tags/java/" rel="tag"># java</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/back-end/big-data/es-10/" rel="prev" title="重学 Elastic Stack 之 Elasticsearch 搜索API大全">
      <i class="fa fa-chevron-left"></i> 重学 Elastic Stack 之 Elasticsearch 搜索API大全
    </a></div>
      <div class="post-nav-item">
    <a href="/back-end/java/mapstruct/" rel="next" title="MapStruct 使用详解">
      MapStruct 使用详解 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#常见的JSON解析类库"><span class="nav-number">1.</span> <span class="nav-text">常见的JSON解析类库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Jackson-简介"><span class="nav-number">2.</span> <span class="nav-text">Jackson 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Maven-依赖"><span class="nav-number">3.</span> <span class="nav-text">Maven 依赖</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ObjectMapper"><span class="nav-number">4.</span> <span class="nav-text">ObjectMapper</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#从JSON中获取Java对象"><span class="nav-number">4.1.</span> <span class="nav-text">从JSON中获取Java对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#简单示例"><span class="nav-number">4.1.1.</span> <span class="nav-text">简单示例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ObjectMapper如何匹配JSON对象的字段和Java对象的属性"><span class="nav-number">4.1.2.</span> <span class="nav-text">ObjectMapper如何匹配JSON对象的字段和Java对象的属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JSON字符串–-gt-Java对象"><span class="nav-number">4.1.3.</span> <span class="nav-text">JSON字符串–&gt;Java对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JSON-字符输入流–-gt-Java对象"><span class="nav-number">4.1.4.</span> <span class="nav-text">JSON 字符输入流–&gt;Java对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JSON文件–-gt-Java对象"><span class="nav-number">4.1.5.</span> <span class="nav-text">JSON文件–&gt;Java对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JSON-via-URL—-gt-Java对象"><span class="nav-number">4.1.6.</span> <span class="nav-text">JSON via URL—&gt;Java对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JSON字节输入流–-gt-Java对象"><span class="nav-number">4.1.7.</span> <span class="nav-text">JSON字节输入流–&gt;Java对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JSON二进制数组–-gt-Java对象"><span class="nav-number">4.1.8.</span> <span class="nav-text">JSON二进制数组–&gt;Java对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JSON数组字符串–-gt-Java对象数组"><span class="nav-number">4.1.9.</span> <span class="nav-text">JSON数组字符串–&gt;Java对象数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JSON数组字符串–-gt-List"><span class="nav-number">4.1.10.</span> <span class="nav-text">JSON数组字符串–&gt;List</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JSON字符串–-gt-Map"><span class="nav-number">4.1.11.</span> <span class="nav-text">JSON字符串–&gt;Map</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#忽略未知的JSON字段"><span class="nav-number">4.1.12.</span> <span class="nav-text">忽略未知的JSON字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不允许基本类型为null"><span class="nav-number">4.1.13.</span> <span class="nav-text">不允许基本类型为null</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义反序列化"><span class="nav-number">4.1.14.</span> <span class="nav-text">自定义反序列化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#将对象写入JSON"><span class="nav-number">4.2.</span> <span class="nav-text">将对象写入JSON</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Java对象–-gt-JSON"><span class="nav-number">4.2.1.</span> <span class="nav-text">Java对象–&gt;JSON</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义序列化"><span class="nav-number">4.2.2.</span> <span class="nav-text">自定义序列化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Jackson-日期转化"><span class="nav-number">4.3.</span> <span class="nav-text">Jackson 日期转化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Date–-gt-long"><span class="nav-number">4.3.1.</span> <span class="nav-text">Date–&gt;long</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Date–-gt-String"><span class="nav-number">4.3.2.</span> <span class="nav-text">Date–&gt;String</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Jackson-JSON-树模型"><span class="nav-number">4.4.</span> <span class="nav-text">Jackson JSON 树模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Jackson-Tree-Model简单例子"><span class="nav-number">4.4.1.</span> <span class="nav-text">Jackson Tree Model简单例子</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Jackson-JsonNode类"><span class="nav-number">4.4.2.</span> <span class="nav-text">Jackson JsonNode类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Java对象–-gt-JsonNode"><span class="nav-number">4.4.3.</span> <span class="nav-text">Java对象–&gt;JsonNode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JsonNode–-gt-Java对象"><span class="nav-number">4.4.4.</span> <span class="nav-text">JsonNode–&gt;Java对象</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JsonNode"><span class="nav-number">5.</span> <span class="nav-text">JsonNode</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JsonNode-vs-ObjectNode"><span class="nav-number">5.1.</span> <span class="nav-text">JsonNode vs ObjectNode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JSON–-gt-JsonNode"><span class="nav-number">5.2.</span> <span class="nav-text">JSON–&gt;JsonNode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JsonNode–-gt-JSON"><span class="nav-number">5.3.</span> <span class="nav-text">JsonNode–&gt;JSON</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#获取JsonNode字段"><span class="nav-number">5.4.</span> <span class="nav-text">获取JsonNode字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在路径中获取JsonNode字段"><span class="nav-number">5.5.</span> <span class="nav-text">在路径中获取JsonNode字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#转换JsonNode字段"><span class="nav-number">5.6.</span> <span class="nav-text">转换JsonNode字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建一个ObjectNode"><span class="nav-number">5.7.</span> <span class="nav-text">创建一个ObjectNode</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set-ObjectNode字段"><span class="nav-number">5.8.</span> <span class="nav-text">Set ObjectNode字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Put-ObjectNode字段"><span class="nav-number">5.9.</span> <span class="nav-text">Put ObjectNode字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除字段"><span class="nav-number">5.10.</span> <span class="nav-text">删除字段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#循环JsonNode字段"><span class="nav-number">5.11.</span> <span class="nav-text">循环JsonNode字段</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JsonParser"><span class="nav-number">6.</span> <span class="nav-text">JsonParser</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建一个JsonParser"><span class="nav-number">6.1.</span> <span class="nav-text">创建一个JsonParser</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用JsonParser转化JSON"><span class="nav-number">6.2.</span> <span class="nav-text">用JsonParser转化JSON</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JsonGenerator"><span class="nav-number">7.</span> <span class="nav-text">JsonGenerator</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建一个JsonGenerator"><span class="nav-number">7.1.</span> <span class="nav-text">创建一个JsonGenerator</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用JsonGenerator生成JSON"><span class="nav-number">7.2.</span> <span class="nav-text">使用JsonGenerator生成JSON</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关闭JsonGenerator"><span class="nav-number">7.3.</span> <span class="nav-text">关闭JsonGenerator</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Jackson注解"><span class="nav-number">8.</span> <span class="nav-text">Jackson注解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Read-Write注解"><span class="nav-number">8.1.</span> <span class="nav-text">Read + Write注解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JsonIgnore"><span class="nav-number">8.1.1.</span> <span class="nav-text">@JsonIgnore</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JsonIgnoreProperties"><span class="nav-number">8.1.2.</span> <span class="nav-text">@JsonIgnoreProperties</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JsonIgnoreType"><span class="nav-number">8.1.3.</span> <span class="nav-text">@JsonIgnoreType</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JsonAutoDetect"><span class="nav-number">8.2.</span> <span class="nav-text">@JsonAutoDetect</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Read注解"><span class="nav-number">8.3.</span> <span class="nav-text">Read注解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JsonSetter"><span class="nav-number">8.3.1.</span> <span class="nav-text">@JsonSetter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JsonAnySetter"><span class="nav-number">8.3.2.</span> <span class="nav-text">@JsonAnySetter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JsonCreator"><span class="nav-number">8.3.3.</span> <span class="nav-text">@JsonCreator</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JacksonInject"><span class="nav-number">8.3.4.</span> <span class="nav-text">@JacksonInject</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JsonDeserialize"><span class="nav-number">8.3.5.</span> <span class="nav-text">@JsonDeserialize</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Write注解"><span class="nav-number">8.4.</span> <span class="nav-text">Write注解</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#JsonInclude"><span class="nav-number">8.4.1.</span> <span class="nav-text">@JsonInclude</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JsonGetter"><span class="nav-number">8.4.2.</span> <span class="nav-text">@JsonGetter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JsonAnyGetter"><span class="nav-number">8.4.3.</span> <span class="nav-text">@JsonAnyGetter</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JsonPropertyOrder"><span class="nav-number">8.4.4.</span> <span class="nav-text">@JsonPropertyOrder</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JsonRawValue"><span class="nav-number">8.4.5.</span> <span class="nav-text">@JsonRawValue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JsonValue"><span class="nav-number">8.4.6.</span> <span class="nav-text">@JsonValue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JsonSerialize"><span class="nav-number">8.4.7.</span> <span class="nav-text">@JsonSerialize</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JsonTypeInfo-多态类型"><span class="nav-number">8.5.</span> <span class="nav-text">@JsonTypeInfo 多态类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">9.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Richard"
      src="https://avatars3.githubusercontent.com/u/18113256?v=3&s=460">
  <p class="site-author-name" itemprop="name">Richard</p>
  <div class="site-description" itemprop="description">惶者生存，偏执者成功</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">132</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">59</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xinlc" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xinlc" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/xinlc" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;xinlc" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://learnxinyminutes.com/" title="https:&#x2F;&#x2F;learnxinyminutes.com" rel="noopener" target="_blank">Learn X in Y minutes</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://justjavac.com/" title="http:&#x2F;&#x2F;justjavac.com" rel="noopener" target="_blank">justjavac</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.ruanyifeng.com/blog/" title="http:&#x2F;&#x2F;www.ruanyifeng.com&#x2F;blog&#x2F;" rel="noopener" target="_blank">阮一峰</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.liaoxuefeng.com/" title="https:&#x2F;&#x2F;www.liaoxuefeng.com" rel="noopener" target="_blank">廖雪峰</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://tech.meituan.com/" title="https:&#x2F;&#x2F;tech.meituan.com" rel="noopener" target="_blank">美团技术</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.v2ex.com/" title="https:&#x2F;&#x2F;www.v2ex.com" rel="noopener" target="_blank">V2EX</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://caniuse.com/" title="https:&#x2F;&#x2F;caniuse.com" rel="noopener" target="_blank">caniuse/工具</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.css88.com/nav/" title="http:&#x2F;&#x2F;www.css88.com&#x2F;nav&#x2F;" rel="noopener" target="_blank">css88/doc</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://overapi.com/" title="http:&#x2F;&#x2F;overapi.com&#x2F;" rel="noopener" target="_blank">OverAPI/api</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://devdocs.io/" title="http:&#x2F;&#x2F;devdocs.io&#x2F;" rel="noopener" target="_blank">DevDocs/api</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://tool.oschina.net/" title="http:&#x2F;&#x2F;tool.oschina.net&#x2F;" rel="noopener" target="_blank">在线工具/索引</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://tool.lu/" title="http:&#x2F;&#x2F;tool.lu&#x2F;" rel="noopener" target="_blank">ToolBox</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://hao.shejidaren.com/" title="http:&#x2F;&#x2F;hao.shejidaren.com&#x2F;" rel="noopener" target="_blank">设计导航</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Richard</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>














  

  

</body>
</html>
