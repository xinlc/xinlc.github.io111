<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico">
  <link rel="mask-icon" href="/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.lichao.xin","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"3ZZ8ITB7HE","apiKey":"062eb5a54afbcbf3f20452d58fc40035","indexName":"xinlc","hits":{"per_page":10},"labels":{"input_placeholder":"搜索","hits_empty":"未发现与「${query}」相关的内容","hits_stats":"${hits} 条相关条目，使用了 ${time} 毫秒"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Java 8（2014 年 3 月发布） 可谓是自 Java 5 以来最具革命性的版本了，它在语言、编译器、类库、开发工具以及 Java 虚拟机等方面都带来了不少新特性。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java8 新特性汇总">
<meta property="og:url" content="https://blog.lichao.xin/back-end/java/java8/index.html">
<meta property="og:site_name" content="Richard Xin&#39;s Blog">
<meta property="og:description" content="Java 8（2014 年 3 月发布） 可谓是自 Java 5 以来最具革命性的版本了，它在语言、编译器、类库、开发工具以及 Java 虚拟机等方面都带来了不少新特性。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.lichao.xin/images/java/java8/2.jpg">
<meta property="og:image" content="https://blog.lichao.xin/images/java/java8/reduce.png">
<meta property="article:published_time" content="2019-12-01T21:25:00.000Z">
<meta property="article:modified_time" content="2021-06-14T01:33:22.387Z">
<meta property="article:author" content="Richard">
<meta property="article:tag" content="java">
<meta property="article:tag" content="java8">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.lichao.xin/images/java/java8/2.jpg">

<link rel="canonical" href="https://blog.lichao.xin/back-end/java/java8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java8 新特性汇总 | Richard Xin's Blog</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4530ac9d0bc4e258535c4a9b17029f0c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Richard Xin's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Richard Xin's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Quick notes</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">132</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">59</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">12</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.lichao.xin/back-end/java/java8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/18113256?v=3&s=460">
      <meta itemprop="name" content="Richard">
      <meta itemprop="description" content="惶者生存，偏执者成功">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Richard Xin's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java8 新特性汇总
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-01 21:25:00" itemprop="dateCreated datePublished" datetime="2019-12-01T21:25:00+00:00">2019-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-14 01:33:22" itemprop="dateModified" datetime="2021-06-14T01:33:22+00:00">2021-06-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><code>Java 8</code>（2014 年 3 月发布） 可谓是自 <code>Java 5</code> 以来最具革命性的版本了，它在语言、编译器、类库、开发工具以及 Java 虚拟机等方面都带来了不少新特性。</p>
<a id="more"></a>

<h2 id="Lambda-表达式"><a href="#Lambda-表达式" class="headerlink" title="Lambda 表达式"></a>Lambda 表达式</h2><p><code>Lambda</code> 表达式可以说是 Java 8 最大的卖点，它将函数式编程引入了 Java。Lambda 允许把函数作为一个方法的参数，或者把代码看成数据。</p>
<p>首先以简单的字符串排序为例来展示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">"peter"</span>, <span class="string">"anna"</span>, <span class="string">"mike"</span>, <span class="string">"xenia"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// java 8 之前</span></span><br><span class="line">Collections.sort(names, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b.compareTo(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>一个 Lambda 表达式可以由用逗号分隔的参数列表、–&gt;符号与函数体三部分表示。下面用 Java 8 中提供的一种更短的 Lambda 表达式的方法来完成该工作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Lambda 简化，-&gt; 后是函数体，默认返回执行后的结果，如果想返回指定结果可以使用 &#123;&#125; 括起来写 return</span></span><br><span class="line">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者这种更简短的方式</span></span><br><span class="line">names.sort((a, b) -&gt; b.compareTo(a));</span><br></pre></td></tr></table></figure>

<h2 id="Functional-Interfaces"><a href="#Functional-Interfaces" class="headerlink" title="Functional Interfaces"></a>Functional Interfaces</h2><p>为了使现有函数更好的支持 Lambda 表达式，Java 8 引入了函数式接口的概念。但它是一个特殊的接口：<code>SAM</code> 类型的接口（Single Abstract Method），函数式接口就是只有一个方法的普通接口。</p>
<p><code>java.lang.Runnable</code> 与 <code>java.util.concurrent.Callable</code> 是函数式接口最典型的例子。为此，Java 8 增加了一种特殊的注解 <code>@FunctionalInterface</code>，这种所谓的函数式接口必须只能包含一个抽象方法，而每个该类型的 Lambda 表达式都会关联到这个抽象方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Converter.java</span></span><br><span class="line"><span class="comment">// 声明函数式接口</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">F</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">convert</span><span class="params">(F from)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test.java</span></span><br><span class="line">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</span><br><span class="line">Integer converted = converter.convert(<span class="string">"123"</span>);</span><br><span class="line">System.out.println(converted);    <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<h3 id="Built-in-Functional-Interfaces"><a href="#Built-in-Functional-Interfaces" class="headerlink" title="Built-in Functional Interfaces"></a>Built-in Functional Interfaces</h3><p>JDK 1.8 的 API 中包含了许多的内建的函数式接口，其中部分的譬如 Comparator、Runnable 被改写成了可以由 Lambda 表达式支持的方式。除此之外，Java 8 还添加了许多来自于 Guava 中的依赖库，并将其改造为了 Lambda 接口。</p>
<h3 id="Suppliers"><a href="#Suppliers" class="headerlink" title="Suppliers"></a>Suppliers</h3><p>其简洁的声明，会让人以为不是函数。这个抽象方法的声明，同 Consumer 相反，是一个只声明了返回值，不需要参数的函数（这还叫函数？）。也就是说 Supplier 其实表达的不是从一个参数空间到结果空间的映射能力，而是表达一种生成能力。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Supplier&lt;Person&gt; personSupplier = Person::<span class="keyword">new</span>;</span><br><span class="line">personSupplier.get();   <span class="comment">// new Person</span></span><br></pre></td></tr></table></figure>

<p>其他 Supplier 扩展接口：</p>
<ul>
<li><code>BooleanSupplier</code>：boolean getAsBoolean(); 返回 boolean；</li>
<li><code>DoubleSupplier</code>：double getAsDouble(); 返回 double；</li>
<li><code>IntSupplier</code>：int getAsInt(); 返回 int；</li>
<li><code>LongSupplier</code>：long getAsLong(); 返回 long；</li>
</ul>
<h3 id="Consumers"><a href="#Consumers" class="headerlink" title="Consumers"></a>Consumers</h3><p>这个接口声明太重要了，应用场景太多了。因为需要返回值的我们用 Function，不需要返回值的，我们用它就可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(<span class="string">"Hello, "</span> + p.firstName);</span><br><span class="line">greeter.accept(<span class="keyword">new</span> Person(<span class="string">"Luke"</span>, <span class="string">"Skywalker"</span>));</span><br></pre></td></tr></table></figure>

<p>看其源码，还有个默认方法 andThen：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(after);</span><br><span class="line">    <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>andThen 可以实现消费两次。消费一次后，继续消费一次。</p>
<p>其他 Consumer 扩展接口：</p>
<ul>
<li><code>BiConsumer</code>：void accept(T t, U u); 接受两个参数；</li>
<li><code>DoubleConsumer</code>：void accept(double value); 接受一个 double 参数；</li>
<li><code>IntConsumer</code>：void accept(int value); 接受一个 int 参数；</li>
<li><code>LongConsumer</code>：void accept(long value); 接受一个 long 参数；</li>
<li><code>ObjDoubleConsumer</code>：void accept(T t, double value); 接受一个泛型参数一个 double 参数；</li>
<li><code>ObjIntConsumer</code>：void accept(T t, int value); 接受一个泛型参数一个 int 参数；</li>
<li><code>ObjLongConsumer</code>：void accept(T t, long value); 接受一个泛型参数一个 long 参数；</li>
</ul>
<h3 id="Predicates"><a href="#Predicates" class="headerlink" title="Predicates"></a>Predicates</h3><p>Predicates 是包含一个参数的返回为布尔值的接口（断言接口），其默认方法也封装了 and、or 和 negate 逻辑和一个静态方法 isEqual。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// and 方法接收一个 Predicate 类型，也就是将传入的条件和当前条件以并且的关系过滤数据。</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">and</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(other);</span><br><span class="line">    <span class="keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or 方法同样接收一个 Predicate 类型，将传入的条件和当前的条件以或者的关系过滤数据</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">or</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(other);</span><br><span class="line">    <span class="keyword">return</span> (t) -&gt; test(t) || other.test(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// negate 就是将当前条件取反</span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">negate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (t) -&gt; !test(t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">Predicate&lt;T&gt; <span class="title">isEqual</span><span class="params">(Object targetRef)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">null</span> == targetRef)</span><br><span class="line">            ? Objects::isNull</span><br><span class="line">            : object -&gt; targetRef.equals(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">conditionFilterAnd</span><span class="params">(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate,Predicate&lt;Integer&gt; predicate2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> list.stream().filter(predicate.and(predicate2)).collect(Collectors.toList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">conditionFilterOr</span><span class="params">(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate,Predicate&lt;Integer&gt; predicate2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> list.stream().filter(predicate.or(predicate2)).collect(Collectors.toList());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">conditionFilterNegate</span><span class="params">(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> list.stream().filter(predicate.negate()).collect(Collectors.toList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大于 5 并且是偶数</span></span><br><span class="line">result = predicateTest.conditionFilterAnd(list, integer -&gt; integer &gt; <span class="number">5</span>, integer1 -&gt; integer1 % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">result.forEach(System.out::println); <span class="comment">// 6 8 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 大于 5 或者是偶数</span></span><br><span class="line">result = predicateTest.conditionFilterOr(list, integer -&gt; integer &gt; <span class="number">5</span>, integer1 -&gt; integer1 % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">result.forEach(System.out::println); <span class="comment">// 2 4 6 8 9 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件取反</span></span><br><span class="line">result = predicateTest.conditionFilterNegate(list,integer2 -&gt; integer2 &gt; <span class="number">5</span>);</span><br><span class="line">result.forEach(System.out::println); <span class="comment">// 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// isEqual 方法返回类型也是 Predicate，也就是说通过 isEqual 方法得到的也是一个用来进行条件判断的函数式接口实例。而返回的这个函数式接口实例是通过传入的 targetRef 的 equals 方法进行判断的。Predicate 接口中的唯一一个静态方法。</span></span><br><span class="line">System.out.println(Predicate.isEqual(<span class="string">"test"</span>).test(<span class="string">"test"</span>)); <span class="comment">// true</span></span><br><span class="line">System.out.println(Predicate.isEqual(<span class="keyword">null</span>).test(<span class="string">"test"</span>)); <span class="comment">// false</span></span><br><span class="line">System.out.println(Predicate.isEqual(<span class="keyword">null</span>).test(<span class="keyword">null</span>)); <span class="comment">// true</span></span><br><span class="line">System.out.println(Predicate.isEqual(<span class="number">1</span>).test(<span class="keyword">new</span> Integer(<span class="number">1</span>))); <span class="comment">// true</span></span><br><span class="line">System.out.println(Predicate.isEqual(<span class="keyword">new</span> Long(<span class="number">1</span>)).test(<span class="keyword">new</span> Integer(<span class="number">1</span>))); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>其他 Predicate 扩展接口：</p>
<ul>
<li><code>BiPredicate</code>：boolean test(T t, U u); 接受两个参数的, 判断返回 bool；</li>
<li><code>DoublePredicate</code>：boolean test(double value); 入参为 double 的谓词函数；</li>
<li><code>IntPredicate</code>：boolean test(int value); 入参为 int 的谓词函数；</li>
<li><code>LongPredicate</code>：boolean test(long value); 入参为 long 的谓词函数；</li>
</ul>
<h3 id="Functions"><a href="#Functions" class="headerlink" title="Functions"></a>Functions</h3><p>Functions 接口接受一个参数并且产生一个结果，是很上层的一个抽象。除了一个抽象方法 apply 外，提供了默认的 3 个 default 方法来链式组合不同的函数 compose，andThen 和 identity。</p>
<p>compose 和 andThen 的不同之处是函数执行的顺序不同。andThen 就是按照正常思维：先执行调用者，再执行入参的。然后 compose 是反着来的，这点需要注意。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;Integer, Integer&gt; times2 = i -&gt; i * <span class="number">2</span>; <span class="comment">// 加倍函数</span></span><br><span class="line">Function&lt;Integer, Integer&gt; squared = i -&gt; i * i; <span class="comment">// 平方函数</span></span><br><span class="line"></span><br><span class="line">System.out.println(times2.apply(<span class="number">4</span>)); <span class="comment">// 8</span></span><br><span class="line">System.out.println(squared.apply(<span class="number">4</span>)); <span class="comment">// 16</span></span><br><span class="line"></span><br><span class="line">System.out.println(times2.compose(squared).apply(<span class="number">4</span>));  <span class="comment">// 32   先4×4然后16×2, 先执行参数，再执行调用者</span></span><br><span class="line">System.out.println(times2.andThen(squared).apply(<span class="number">4</span>));  <span class="comment">// 64   先4×2,然后8×8, 先执行调用者，再执行参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 看看这个例子 Function.identity() 构建出一个恒等式函数而已，方便方法的连缀 这就是它的唯一优点</span></span><br><span class="line">System.out.println(Function.identity().compose(squared).apply(<span class="number">4</span>));   <span class="comment">// 16 先执行4*4,再执行identity 值不变</span></span><br></pre></td></tr></table></figure>

<p>由 Function，可以扩展出高阶函数。如泛型中有个类型还是 Function，这种需要还是经常有的，所以 BiFunction 提供了二元函数的一个接口声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二元函数没有 compose 能力，只是默认实现了 andThen。有了一元和二元函数，那么可以通过组合扩展出更多的函数可能。</span></span><br><span class="line">BiFunction&lt;Integer, Integer, Integer&gt; biFunction = (x, y) -&gt; x + y;</span><br><span class="line">System.out.println(biFunction.apply(<span class="number">4</span>, <span class="number">5</span>)); <span class="comment">// 9</span></span><br><span class="line">System.out.println(biFunction.andThen(x -&gt; x + <span class="number">10</span>).apply(<span class="number">4</span>, <span class="number">5</span>)); <span class="comment">// 19</span></span><br></pre></td></tr></table></figure>

<p>Function 相关扩展接口：</p>
<ul>
<li><code>BiFunction</code>：R apply(T t, U u); 接受两个参数，返回一个值，代表一个二元函数；</li>
<li><code>DoubleFunction</code>：R apply(double value); 只处理 double 类型的一元函数；</li>
<li><code>ToDoubleFunction</code>：double applyAsDouble(T value); 返回 double 的一元函数；</li>
<li><code>ToDoubleBiFunction</code>：double applyAsDouble(T t, U u); 返回 double 的二元函数；</li>
<li><code>IntToLongFunction</code>：long applyAsLong(int value); 接受 int 返回 long 的一元函数；</li>
</ul>
<h3 id="Operator"><a href="#Operator" class="headerlink" title="Operator"></a>Operator</h3><p>Operator 其实就是 Function，函数有时候也叫作算子。算子在 Java 8 中接口描述更像是函数的补充，和上面的很多类型映射型函数类似。它包含 UnaryOperator 和 BinaryOperator。分别对应单元算子和二元算子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">UnaryOperator&lt;Integer&gt; unaryOperator = x -&gt; x + <span class="number">10</span>;</span><br><span class="line">BinaryOperator&lt;Integer&gt; binaryOperator = (x, y) -&gt; x + y;</span><br><span class="line"></span><br><span class="line">System.out.println(unaryOperator.apply(<span class="number">10</span>)); <span class="comment">// 20</span></span><br><span class="line">System.out.println(binaryOperator.apply(<span class="number">5</span>, <span class="number">10</span>)); <span class="comment">// 15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BinaryOperator 提供了两个默认的 static 快捷实现，帮助实现二元函数 min(x,y) 和 max(x,y)。</span></span><br><span class="line">BinaryOperator&lt;Integer&gt; min = BinaryOperator.minBy(Integer::compare);</span><br><span class="line">BinaryOperator&lt;Integer&gt; max = BinaryOperator.maxBy(Integer::compareTo);</span><br><span class="line">System.out.println(min.apply(<span class="number">10</span>, <span class="number">20</span>)); <span class="comment">// 10</span></span><br><span class="line">System.out.println(max.apply(<span class="number">10</span>, <span class="number">20</span>)); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<h2 id="Method-and-Constructor-References"><a href="#Method-and-Constructor-References" class="headerlink" title="Method and Constructor References"></a>Method and Constructor References</h2><p>方法引用（含构造方法引用），通常与 Lambda 表达式联合使用，可以直接引用已有 Java 类或对象的方法。一般有四种不同的方法引用：</p>
<ol>
<li>构造器引用。语法是 <code>Class::new</code>，或者更一般的 <code>Class&lt;T&gt;::new</code>，可无参，可有参数。方法签名保持一致；</li>
<li>静态方法引用。语法是 <code>Class::static_method</code>，要求方法签名保持一致；</li>
<li>特定类的任意对象方法引用。它的语法是 <code>Class::method</code>。要求方法签名保持一致；</li>
<li>特定对象的方法引用，它的语法是 <code>instance::method</code>。要求方法签名保持一致。与 3 不同的地方在于，3 是在列表元素上分别调用方法，而 4 是在某个对象上调用方法，将列表元素作为参数传入；</li>
</ol>
<p>上述的代码可以使用静态方法引用而更加的简化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Converter&lt;String, Integer&gt; converter = Integer::valueOf;</span><br><span class="line">Integer converted = converter.convert(<span class="string">"123"</span>);</span><br><span class="line">System.out.println(converted);   <span class="comment">// 123</span></span><br></pre></td></tr></table></figure>

<p>类::new （构造器引用）:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Student.java</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String stuName;</span><br><span class="line">    <span class="keyword">private</span> Integer stuAge;</span><br><span class="line">    <span class="keyword">private</span> Double stuGrade;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单独写一个 只有一个参数的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String stuName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stuName = stuName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Supplier&lt;Student&gt; supp = () -&gt; new Student(); // 原来写法</span></span><br><span class="line">    <span class="comment">// Function&lt;String, Student&gt; supp = (name) -&gt; new Student(name); // 原来写法</span></span><br><span class="line"></span><br><span class="line">    Supplier&lt;Student&gt; supp = Student::<span class="keyword">new</span>; <span class="comment">// 无参构造</span></span><br><span class="line">    Function&lt;String, Student&gt;  funOneParam = Student::<span class="keyword">new</span>; <span class="comment">// 有参构造</span></span><br><span class="line">    <span class="comment">// 我们发现如果参数实在太多（超过3个），就不用使用构造函数引用了 (除非自定义一个函数式接口)</span></span><br><span class="line">    <span class="comment">// BiFunction&lt;String,Integer,Function&lt;Double,Student&gt;&gt; suppAllParam = Student::new; // 全参构造</span></span><br><span class="line"></span><br><span class="line">    System.out.println(supp.get()); <span class="comment">// Student(stuName=null, stuAge=null, stuGrade=null)</span></span><br><span class="line">    System.out.println(funOneParam.apply(<span class="string">"fsx"</span>)); <span class="comment">// Student(stuName=fsx, stuAge=null, stuGrade=null)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类::实例方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Student stu = <span class="keyword">new</span> Student(<span class="string">"张三"</span>, <span class="number">18</span>, <span class="number">85.0</span>);</span><br><span class="line">    <span class="comment">// Supplier&lt;String&gt; supp = () -&gt; stu.getStuName();  // 原来写法</span></span><br><span class="line">    Supplier&lt;String&gt; supp = stu::getStuName;      <span class="comment">// 使用方法引用</span></span><br><span class="line">    System.out.println(supp.get()); <span class="comment">// 张三</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类::实例方法二：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RequestTemplate requestTemplate  = <span class="keyword">new</span> RequestTemplate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置请求头，要求接口方法签名保持一致；</span></span><br><span class="line">        setHeader(requestTemplate::header);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setHeader</span><span class="params">(TracingSetter tracingSetter)</span> </span>&#123;</span><br><span class="line">        tracingSetter.set(<span class="string">"X-GroupId"</span>, <span class="string">"1"</span>);</span><br><span class="line">        tracingSetter.set(<span class="string">"X-TracingId"</span>, <span class="string">"1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Tracing信息设置器</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TracingSetter</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 设置tracing属性</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> key   key</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> value value</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(String key, String value)</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lambda-Scopes"><a href="#Lambda-Scopes" class="headerlink" title="Lambda Scopes"></a>Lambda Scopes</h2><p>从 Lambda 表达式中访问外部作用域中变量非常类似于匿名对象，可以访问本地的 final 变量、实例域以及静态变量。</p>
<h3 id="Accessing-local-variables"><a href="#Accessing-local-variables" class="headerlink" title="Accessing local variables"></a>Accessing local variables</h3><p>在匿名对象中，我们可以从 Lambda 表达式的域中访问外部的 final 变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =</span><br><span class="line">        (from) -&gt; String.valueOf(from + num);</span><br><span class="line"></span><br><span class="line">stringConverter.convert(<span class="number">2</span>);     <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>但是不同于匿名对象只能访问 final 变量，Lambda 表达式中可以访问 final 变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =</span><br><span class="line">        (from) -&gt; String.valueOf(from + num);</span><br><span class="line"></span><br><span class="line">stringConverter.convert(<span class="number">2</span>);     <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>不过需要注意的是，尽管变量不需要声明为 final，但是也是隐式的不可变：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下写法就会被报错。</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">Converter&lt;Integer, String&gt; stringConverter =</span><br><span class="line">        (from) -&gt; String.valueOf(from + num);</span><br><span class="line">num = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Java 8 Lambda 表达式中为什么要求外部变量为 final ？</p>
<blockquote>
<p>这是由 Java 对 Lambda 表达式的实现决定的，在 Java 中 Lambda 表达式是匿名类语法上的进一步简化，其本质还是调用对象的方法。<br>在 Java 中方法调用是值传递的，所以在 Lambda 表达式中对变量的操作都是基于原变量的副本，不会影响到原变量的值。<br>综上，假定没有要求 Lambda 表达式外部变量为 final 修饰，那么开发者会误以为外部变量的值能够在 Lambda 表达式中被改变，而这实际是不可能的，所以要求外部变量为 final 是在编译期以强制手段确保用户不会在 Lambda 表达式中做修改原变量值的操作。<br>另外，对 lambda 表达式的支持是拥抱函数式编程，而函数式编程本身不应为函数引入状态，从这个角度看，外部变量为 final 也一定程度迎合了这一特点。</p>
</blockquote>
</blockquote>
<h3 id="Accessing-fields-and-static-variables"><a href="#Accessing-fields-and-static-variables" class="headerlink" title="Accessing fields and static variables"></a>Accessing fields and static variables</h3><p>不同于本地变量，我们可以在 Lambda 表达式中任意的读写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lambda1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> outerStaticNum;</span><br><span class="line">    <span class="keyword">int</span> outerNum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testScopes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; &#123;</span><br><span class="line">            outerNum = <span class="number">23</span>;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(from);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; &#123;</span><br><span class="line">            outerStaticNum = <span class="number">72</span>;</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(from);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Accessing-Default-Interface-Methods"><a href="#Accessing-Default-Interface-Methods" class="headerlink" title="Accessing Default Interface Methods"></a>Accessing Default Interface Methods</h3><p>注意，Lambda 表达式中是不可以访问默认方法的，下面代码是编译通不过的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Formula formula = (a) -&gt; sqrt( a * <span class="number">100</span>);</span><br></pre></td></tr></table></figure>

<h3 id="Lambda-表达式里面给外部变量赋值的问题"><a href="#Lambda-表达式里面给外部变量赋值的问题" class="headerlink" title="Lambda 表达式里面给外部变量赋值的问题"></a>Lambda 表达式里面给外部变量赋值的问题</h3><p>在 Lambda 中修改外部变量，会发现报错 Variable used in lambda expression should be final or effectively final。</p>
<p>前面也说了，这是因为Java会将外部变量的值作为参数传递给 Lambda 表达式，为 Lambda 表达式建立一个副本，它的代码访问的是这个副本，而不是外部声明变量。为什么非要建立副本呢，直接访问外部的变量得多方便呢？</p>
<p>答案是：这是不可能滴，因为外部变量定义在栈中，当 Lambda 表达式被执行的时候，外部变量可能已经被释放掉了。</p>
<p>一定要在 Lambda 表达式里面修改外部变量的值也是可以的，可以将变量定义为实例变量或放入数组、Map、AtomicReference等。</p>
<p><img src="/images/java/java8/2.jpg" alt="2"></p>
<h2 id="Default-Methods-for-Interfaces"><a href="#Default-Methods-for-Interfaces" class="headerlink" title="Default Methods for Interfaces"></a>Default Methods for Interfaces</h2><p>Java 8 允许我们利用 default 关键字来向接口中添加非抽象的方法作为默认方法。所有实现这个接口的类都会接受默认方法的实现，除非子类提供的自己的实现。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Formula.java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Formula</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test.jva</span></span><br><span class="line">Formula formula = <span class="keyword">new</span> Formula() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqrt(a * <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">formula.calculate(<span class="number">100</span>);     <span class="comment">// 100.0</span></span><br><span class="line">formula.sqrt(<span class="number">16</span>);           <span class="comment">// 4.0</span></span><br></pre></td></tr></table></figure>

<p>我们还可以在接口中定义静态方法，使用 static 关键字，也可以提供实现。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StaticFunctionInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">staticFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"static function"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>接口的默认方法和静态方法的引入，其实可以认为引入了 C ＋＋中抽象类的理念，以后我们再也不用在每个实现类中都写重复的代码了。</p>
</blockquote>
<h2 id="Annotations"><a href="#Annotations" class="headerlink" title="Annotations"></a>Annotations</h2><p>在 Java 5 中使用注解有一个限制，即相同的注解在同一位置只能声明一次。Java 8 引 入重复注解，这样相同的注解在同一地方也可以声明多次。重复注解机制本身需要用 <code>@Repeatable</code> 注解。Java 8 在编译器层做了优化，相同注解会以集合的方式保存，因此底层的原理并没有变化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Hints &#123;</span><br><span class="line">    Hint[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repeatable</span>(Hints<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">Hint</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以前的写法，Using the container annotation</span></span><br><span class="line"><span class="meta">@Hints</span>(&#123;<span class="meta">@Hint</span>(<span class="string">"hint1"</span>), <span class="meta">@Hint</span>(<span class="string">"hint2"</span>)&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// java8 写法，Using repeatable annotations</span></span><br><span class="line"><span class="meta">@Hint</span>(<span class="string">"hint1"</span>)</span><br><span class="line"><span class="meta">@Hint</span>(<span class="string">"hint2"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Test.java</span></span><br><span class="line">Hint hint = Person<span class="class">.<span class="keyword">class</span>.<span class="title">getAnnotation</span>(<span class="title">Hint</span>.<span class="title">class</span>)</span>;</span><br><span class="line">System.out.println(hint); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">Hints hints1 = Person<span class="class">.<span class="keyword">class</span>.<span class="title">getAnnotation</span>(<span class="title">Hints</span>.<span class="title">class</span>)</span>;</span><br><span class="line">System.out.println(hints1.value().length); <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">Hint[] hints2 = Person<span class="class">.<span class="keyword">class</span>.<span class="title">getAnnotationsByType</span>(<span class="title">Hint</span>.<span class="title">class</span>)</span>;</span><br><span class="line">System.out.println(hints2.length); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h2 id="扩展注解的支持（类型注解）"><a href="#扩展注解的支持（类型注解）" class="headerlink" title="扩展注解的支持（类型注解）"></a>扩展注解的支持（类型注解）</h2><p>Java 8 扩展了注解的上下文，几乎可以为任何东西添加注解，包括局部变量、泛型类、父类与接口的实现，连方法的异常也能添加注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="meta">@NotNull</span> String name;</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript-引擎-Nashorn"><a href="#JavaScript-引擎-Nashorn" class="headerlink" title="JavaScript 引擎 Nashorn"></a>JavaScript 引擎 Nashorn</h2><p>Nashorn 允许在 JVM 上开发运行 JavaScript 应用，允许 Java 与 JavaScript 相互调用。</p>
<h2 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h2><p>在 Java 8 中，Base64 编码成为了 Java 类库的标准。Base64 类同时还提供了对 URL、MIME 友好的编码器与解码器。</p>
<p>Base64 是一种字符串编码格式，采用了 A-Z，a-z，0-9，“+”和“/”这 64 个字符来编码原始字符（还有垫字符“=”）。一个字符本身是一个字节，也就是 8 位，而 Base64 编码后的一个字符只能表示 6 位的信息。也就是原始字符串中的 3 字节的信息编码会变成 4 字节的信息。Base64 的主要作用是满足 MIME 的传输需求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String orig = <span class="string">"hello world!"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编码加密</span></span><br><span class="line">    String desc = Base64.getEncoder().encodeToString(orig.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">    System.out.println(<span class="string">"加密后的字符串为:"</span> + desc); 加密后的字符串为:aGVsbG8gd29ybGQh</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解码解密</span></span><br><span class="line">    String unDecodeStr=<span class="keyword">new</span> String(Base64.getDecoder().decode(desc), StandardCharsets.UTF_8);</span><br><span class="line">    System.out.println(<span class="string">"解密后的字符串为"</span> + unDecodeStr); <span class="comment">// 解密后的字符串为hello world!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将文件 File 转换为 Base64：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">fileToBase64</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(path);</span><br><span class="line">    FileInputStream inputFile;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        inputFile = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) file.length()];</span><br><span class="line">        inputFile.read(buffer);</span><br><span class="line">        inputFile.close();</span><br><span class="line">        <span class="keyword">return</span> Base64.getEncoder().encodeToString(buffer);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"文件路径无效\n"</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将 Base64 转换为 file 文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">base64ToFile</span><span class="params">(String base64, String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] buffer;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        buffer = Base64.getDecoder().decode(base64);</span><br><span class="line">        FileOutputStream out = <span class="keyword">new</span> FileOutputStream(path);</span><br><span class="line">        out.write(buffer);</span><br><span class="line">        out.close();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"base64字符串异常或地址异常\n"</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Base64 的原理：</p>
<blockquote>
<p>为什么会有 Base64 编码呢？因为有些网络传送渠道并不支持所有的字节，例如传统的邮件只支持可见字符的传送，像 ASCII 码的控制字符就 不能通过邮件传送。这样用途就受到了很大的限制，比如图片二进制流的每个字节不可能全部是可见字符，所以就传送不了。最好的方法就是在不改变传统协议的情 况下，做一种扩展方案来支持二进制文件的传送。把不可打印的字符也能用可打印字符来表示，问题就解决了。Base64 编码应运而生，Base64 就是一种 基于 64 个可打印字符来表示二进制数据的表示方法。</p>
</blockquote>
<p>有一个数组，里面有“A-Z, a-z, 0-9 , + , /”一共 64 个字符。然后对需要处理的的二进制数据做处理：每 3 个字节（24bit）一组，因此按照 6bit 一组为 Base64 的规则可以划为 4 组，每组 6bit，刚好 64 位（对应数组的 64 个值）</p>
<blockquote>
<p>Base64 的码表只有 64 个字符，如果要表达 64 个字符的话，使用 6 的 bit 即可完全表示(2 的 6 次方为 64)。<br>如果是字符串转换为 Base64 码，会先把对应的字符串转换为 ascll 码表对应的数字，然后再把数字转换为 2 进制，比如 a 的 ascll 码味 97，97 的二进制是：01100001，把 8 个二进制提取成 6 个，剩下的 2 个二进制和后面的二进制继续拼接，最后再把 6 个二进制码转换为 Base64 对于的编码。</p>
</blockquote>
<p>所以，Base64 编码会把 3 字节的二进制数据编码为 4 字节的文本数据，长度增加 33%，好处是编码后的文本数据可以在邮件正文、网页等直接显示。</p>
<p>如果要编码的二进制数据不是 3 的倍数，最后会剩下 1 个或 2 个字节怎么办？Base64 用 <code>\x00</code> 字节在末尾补足后，再在编码的末尾加上 1 个或 2 个<code>=</code>号，表示补了多少字节，解码的时候，会自动去掉。</p>
<p>java8 的 Api 提供了 Basic 编码、URL 编码、MIME 编码、对流的支持。</p>
<h2 id="Date-Time-API-JSR-310"><a href="#Date-Time-API-JSR-310" class="headerlink" title="Date/Time API (JSR 310)"></a>Date/Time API (JSR 310)</h2><p>Java 8 新的 Date-Time API (JSR 310) 受 Joda-Time 的影响，提供了新的 <code>java.time</code> 包，可以用来替代 <code>java.util.Date</code> 和 <code>java.util.Calendar</code>。一般会用到 Clock、LocaleDate、LocalTime、LocaleDateTime、ZonedDateTime、Duration 这些类，对于时间日期的改进还是非常不错的。</p>
<h3 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h3><p><code>Clock</code> 方便我们去读取当前的日期与时间。Clocks 可以根据不同的时区来进行创建，并且可以作为<code>System.currentTimeMillis()</code> 的替代。这种指向时间轴的对象即是 Instant 类。Instants 可以被用于创建<code>java.util.Date</code> 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Clock clock = Clock.systemDefaultZone();</span><br><span class="line"><span class="keyword">long</span> millis = clock.millis();</span><br><span class="line"></span><br><span class="line">Instant instant = clock.instant();</span><br><span class="line">Date legacyDate = Date.from(instant);   <span class="comment">// legacy java.util.Date</span></span><br></pre></td></tr></table></figure>

<h3 id="Timezones"><a href="#Timezones" class="headerlink" title="Timezones"></a>Timezones</h3><p>Timezones 以 ZoneId 来区分。可以通过静态构造方法很容易的创建，Timezones 定义了 Instants 与 <code>Local Dates</code> 之间的转化关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ZoneId.getAvailableZoneIds());</span><br><span class="line"><span class="comment">// prints all available timezone ids</span></span><br><span class="line"></span><br><span class="line">ZoneId zone1 = ZoneId.of(<span class="string">"Europe/Berlin"</span>);</span><br><span class="line">ZoneId zone2 = ZoneId.of(<span class="string">"Brazil/East"</span>);</span><br><span class="line">System.out.println(zone1.getRules());</span><br><span class="line">System.out.println(zone2.getRules());</span><br><span class="line"></span><br><span class="line"><span class="comment">// ZoneRules[currentStandardOffset=+01:00]</span></span><br><span class="line"><span class="comment">// ZoneRules[currentStandardOffset=-03:00]</span></span><br></pre></td></tr></table></figure>

<h3 id="LocalTime"><a href="#LocalTime" class="headerlink" title="LocalTime"></a>LocalTime</h3><p><code>LocalTime</code> 代表了一个与时间无关的本地时间，譬如 <code>10pm</code> 或者 <code>17:30:15</code>。下述的代码展示了根据不同的时间轴创建的不同的本地时间：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LocalTime now1 = LocalTime.now(zone1);</span><br><span class="line">LocalTime now2 = LocalTime.now(zone2);</span><br><span class="line"></span><br><span class="line">System.out.println(now1.isBefore(now2));  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> hoursBetween = ChronoUnit.HOURS.between(now1, now2);</span><br><span class="line"><span class="keyword">long</span> minutesBetween = ChronoUnit.MINUTES.between(now1, now2);</span><br><span class="line"></span><br><span class="line">System.out.println(hoursBetween);       <span class="comment">// -3</span></span><br><span class="line">System.out.println(minutesBetween);     <span class="comment">// -239</span></span><br></pre></td></tr></table></figure>

<p>LocalTime 提供了很多的工厂方法来简化创建实例的步骤，以及对于时间字符串的解析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LocalTime late = LocalTime.of(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</span><br><span class="line">System.out.println(late);       <span class="comment">// 23:59:59</span></span><br><span class="line"></span><br><span class="line">DateTimeFormatter germanFormatter =</span><br><span class="line">    DateTimeFormatter</span><br><span class="line">        .ofLocalizedTime(FormatStyle.SHORT)</span><br><span class="line">        .withLocale(Locale.GERMAN);</span><br><span class="line"></span><br><span class="line">LocalTime leetTime = LocalTime.parse(<span class="string">"13:37"</span>, germanFormatter);</span><br><span class="line">System.out.println(leetTime);   <span class="comment">// 13:37</span></span><br></pre></td></tr></table></figure>

<h3 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a>LocalDate</h3><p>LocalDate 代表了一个独立的时间类型，譬如 <code>2014-03-11</code>。它是一个不可变的对象并且很类似于 LocalTime。下列代码展示了如何通过增减时间年月来计算日期：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">LocalDate tomorrow = today.plus(<span class="number">1</span>, ChronoUnit.DAYS);</span><br><span class="line">LocalDate yesterday = tomorrow.minusDays(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">LocalDate independenceDay = LocalDate.of(<span class="number">2014</span>, Month.JULY, <span class="number">4</span>);</span><br><span class="line">DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();</span><br><span class="line">System.out.println(dayOfWeek);    <span class="comment">// FRIDAY</span></span><br></pre></td></tr></table></figure>

<p>从字符串解析得到 LocalDate 对象也像 LocalTime 一样简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter germanFormatter =</span><br><span class="line">    DateTimeFormatter</span><br><span class="line">        .ofLocalizedDate(FormatStyle.MEDIUM)</span><br><span class="line">        .withLocale(Locale.GERMAN);</span><br><span class="line"></span><br><span class="line">LocalDate xmas = LocalDate.parse(<span class="string">"24.12.2014"</span>, germanFormatter);</span><br><span class="line">System.out.println(xmas);   <span class="comment">// 2014-12-24</span></span><br></pre></td></tr></table></figure>

<h3 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h3><p>LocalDateTime 代表了时间日期类型，它组合了上文提到的 Date 类型以及 Time 类型。LocalDateTime 同样也是一种不可变类型，很类似于 LocalTime 以及 LocalDate。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime sylvester = LocalDateTime.of(<span class="number">2014</span>, Month.DECEMBER, <span class="number">31</span>, <span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</span><br><span class="line"></span><br><span class="line">DayOfWeek dayOfWeek = sylvester.getDayOfWeek();</span><br><span class="line">System.out.println(dayOfWeek);      <span class="comment">// WEDNESDAY</span></span><br><span class="line"></span><br><span class="line">Month month = sylvester.getMonth();</span><br><span class="line">System.out.println(month);          <span class="comment">// DECEMBER</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);</span><br><span class="line">System.out.println(minuteOfDay);    <span class="comment">// 1439</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取秒数</span></span><br><span class="line">Long second = LocalDateTime.now().toEpochSecond(ZoneOffset.of(<span class="string">"+8"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取毫秒数</span></span><br><span class="line">Long timestamp = LocalDateTime.now().toInstant(ZoneOffset.of(<span class="string">"+8"</span>)).toEpochMilli();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间戳转换成 LocalDateTime</span></span><br><span class="line">LocalDateTime time = LocalDateTime.ofEpochSecond(timestamp/<span class="number">1000</span>, <span class="number">0</span>, ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间转字符串格式化</span></span><br><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">"yyyyMMddHHmmssSSS"</span>);</span><br><span class="line">String dateTime = LocalDateTime.now(ZoneOffset.of(<span class="string">"+8"</span>)).format(formatter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串转时间</span></span><br><span class="line">String dateTimeStr = <span class="string">"2020-05-01 17:10:10"</span>;</span><br><span class="line">DateTimeFormatter df = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">LocalDateTime dateTime = LocalDateTime.parse(dateTimeStr, df)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将java.util.Date 转换为 java.time.LocalDateTime, 默认时区为东8区</span></span><br><span class="line"><span class="comment">// dateConvertToLocalDateTime</span></span><br><span class="line">date.toInstant().atOffset(ZoneOffset.of(<span class="string">"+8"</span>)).toLocalDateTime();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 java.time.LocalDateTime 转换为 java.util.Date, 默认时区为东8区</span></span><br><span class="line"><span class="comment">// localDateTimeConvertToDate</span></span><br><span class="line">Date.from(localDateTime.toInstant(ZoneOffset.of(<span class="string">"+8"</span>)))</span><br></pre></td></tr></table></figure>

<p>上文中提及的 Instant 也可以用来将时间根据时区转化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Instant instant = sylvester</span><br><span class="line">        .atZone(ZoneId.systemDefault())</span><br><span class="line">        .toInstant();</span><br><span class="line"></span><br><span class="line">Date legacyDate = Date.from(instant);</span><br><span class="line">System.out.println(legacyDate);     <span class="comment">// Wed Dec 31 23:59:59 CET 2014</span></span><br></pre></td></tr></table></figure>

<p>从格式化字符串中解析获取到数据对象，也是非常简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter formatter =</span><br><span class="line">    DateTimeFormatter</span><br><span class="line">        .ofPattern(<span class="string">"MMM dd, yyyy - HH:mm"</span>);</span><br><span class="line"></span><br><span class="line">LocalDateTime parsed = LocalDateTime.parse(<span class="string">"Nov 03, 2014 - 07:13"</span>, formatter);</span><br><span class="line">String string = formatter.format(parsed);</span><br><span class="line">System.out.println(string);     <span class="comment">// Nov 03, 2014 - 07:13</span></span><br></pre></td></tr></table></figure>

<h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>Java 8 引入 Optional 类来防止空指针异常，Optional 类最先是由 Google 的 Guava 项目引入的。Optional 类实际上是个容器：它可以保存类型 T 的值，或者保存 null。使用 Optional 类我们就不用显式进行空指针检查了。</p>
<h3 id="创建一个-Optional"><a href="#创建一个-Optional" class="headerlink" title="创建一个 Optional"></a>创建一个 Optional</h3><p>Optional 本质是一个容器，需要我们将对象实例传入该容器中。Optional 的构造方法为 private，无法直接使用 new 构建对象，只能使用 Optional 提供的静态方法创建。</p>
<p>Optional 三个创建方法如下：</p>
<ul>
<li><code>Optional.of(obj)</code>,如果对象为 null，将会抛出 NPE。</li>
<li><code>Optional.ofNullable(obj)</code>, 如果对象为 null, 将会创建不包含值的 empty Optional 对象实例。</li>
<li><code>Optional.empty()</code> 等同于 <code>Optional.ofNullable(null)</code></li>
</ul>
<p>只有在确定对象不会为 null 的情况使用 <code>Optional.of</code>，否则建议使用 <code>Optional.ofNullable</code>方法。</p>
<h3 id="get-与-isPresent"><a href="#get-与-isPresent" class="headerlink" title="get 与 isPresent"></a>get 与 isPresent</h3><p>对象实例存入 Optional 容器中之后，最后我们需要从中取出。<code>Optional.get</code> 方法用于取出内部对象实例，不过需要注意的是，如果是 empty Optional 实例，由于容器内没有任何对象实例，使用 get 方法将会抛出 <code>NoSuchElementException</code> 异常。</p>
<p>为了防止异常抛出，可以使用 <code>Optional.isPresent</code>。这个方法将会判断内部是否存在对象实例，若存在则返回 true。</p>
<p>示例代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Company&gt; optCompany = Optional.ofNullable(company);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与直接使用空指针判断没有任何区别</span></span><br><span class="line"><span class="keyword">if</span> (optCompany.isPresent()) &#123;</span><br><span class="line">    System.out.println(optCompany.get().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仔细对比，可以发现上面用法与空指针检查并无差别。刚接触到 Optional ，看到很多文章介绍这个用法，那时候一直很疑惑，这个解决方案不是更加麻烦？其实这个是不建议使用的，应使用 Java8 Stream API。</p>
<h3 id="ifPresent"><a href="#ifPresent" class="headerlink" title="ifPresent"></a>ifPresent</h3><p>通常情况下，空指针检查之后，如果对象不为空，将会进行下一步处理，比如打印该对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Company company = ...;</span><br><span class="line"><span class="keyword">if</span>(company != <span class="keyword">null</span>)&#123;</span><br><span class="line">    System.out.println(company);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码我们可以使用 <code>Optional.ifPresent</code> 代替，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Company&gt; optCompany = ...;</span><br><span class="line">optCompany.ifPresent(System.out::println);</span><br></pre></td></tr></table></figure>

<p>使用 ifPresent 方法，我们不用再显示的进行检查，如果 Optional 为空，上面例子将不再输出。</p>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h3><p>有时候我们需要某些属性满足一定条件，才进行下一步动作。这里假设我们当 Company name 属性为 Apple，打印输出 ok。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (company != <span class="keyword">null</span> &amp;&amp; <span class="string">"Apple"</span>.equals(company.getName())) &#123;</span><br><span class="line">    System.out.println(<span class="string">"ok"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面使用 <code>Optional.filter</code> 结合 <code>Optional.ifPresent</code> 重写上面的代码，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;Company&gt; companyOpt=...;</span><br><span class="line">companyOpt</span><br><span class="line">        .filter(company -&gt; <span class="string">"Apple"</span>.equals(company.getName()))</span><br><span class="line">        .ifPresent(company -&gt; System.out.println(<span class="string">"ok"</span>));</span><br></pre></td></tr></table></figure>

<p>filter 方法将会判断对象是否符合条件。如果不符合条件，将会返回一个空的 Optional 。</p>
<h3 id="orElse-与-orElseThrow"><a href="#orElse-与-orElseThrow" class="headerlink" title="orElse 与 orElseThrow"></a>orElse 与 orElseThrow</h3><p>当一个对象为 null 时，业务上通常可以设置一个默认值，从而使流程继续下去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String name = company != <span class="keyword">null</span> ? company.getName() : <span class="string">"Unknown"</span>;</span><br></pre></td></tr></table></figure>

<p>或者抛出一个内部异常，记录失败原因，快速失败。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (company.getName() == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Optional 类提供两个方法 orElse 与 orElseThrow ，可以方便完成上面转化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置默认值</span></span><br><span class="line">String name = companyOpt.orElse(<span class="keyword">new</span> Company(<span class="string">"Unknown"</span>)).getName();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抛出异常</span></span><br><span class="line">String name = companyOpt.orElseThrow(RuntimeException::<span class="keyword">new</span>).getName();</span><br></pre></td></tr></table></figure>

<p>如果 Optional 为空，提供默认值或抛出异常。</p>
<h3 id="map-与-flatMap-函数隆重登场"><a href="#map-与-flatMap-函数隆重登场" class="headerlink" title="map 与 flatMap 函数隆重登场"></a>map 与 flatMap 函数隆重登场</h3><p>map 应该是最常用的了，先上示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map</span></span><br><span class="line">String result = Optional.ofNullable(user)</span><br><span class="line">    .map(User::getName)</span><br><span class="line">    .orElseThrow(() -&gt; <span class="keyword">new</span> BusinessException(<span class="string">"xxx"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// flatMap</span></span><br><span class="line">String result = Optional.ofNullable(user)</span><br><span class="line">    .flatMap(User::getAddress)</span><br><span class="line">    .flatMap(Address::getCountry)</span><br><span class="line">    .map(Country::getIsocode)</span><br><span class="line">    .orElse(<span class="string">"default"</span>);</span><br></pre></td></tr></table></figure>

<p>map(Function)：对 Optional 中保存的值进行函数运算，并返回新的 Optional(可以是任何类型)。</p>
<p>flatMap()：功能与 map() 相似具体区别请参考 Stream API，其实就是把多维数组扁平化为一维。</p>
<h3 id="代替三目运算"><a href="#代替三目运算" class="headerlink" title="代替三目运算"></a>代替三目运算</h3><p>Optional 还有一个作用，三目运算符，可以代替三目运算符从而支持方法连缀。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(Optional.ofNullable(<span class="string">"demo"</span>).orElse(<span class="string">"a"</span>)); <span class="comment">//demo</span></span><br><span class="line">    System.out.println(Optional.ofNullable(<span class="keyword">null</span>).orElse(<span class="string">"a"</span>)); <span class="comment">//a</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//或者 使用supplier生产</span></span><br><span class="line">    System.out.println(Optional.ofNullable(<span class="keyword">null</span>).orElseGet(() -&gt; <span class="string">"abc"</span>)); <span class="comment">//abc</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//此处会直接抛出空指针异常</span></span><br><span class="line">    <span class="comment">//Optional&lt;String&gt; s = Optional.&lt;String&gt;of(null); //java.lang.NullPointerException</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//s可以直接使用，是empty，但是不能get，请配合isPresent()使用</span></span><br><span class="line">    <span class="comment">//Optional&lt;String&gt; s = Optional.&lt;String&gt;ofNullable(null);</span></span><br><span class="line">    <span class="comment">//System.out.println(s); //Optional.empty</span></span><br><span class="line">    <span class="comment">//System.out.println(s.get()); //java.util.NoSuchElementException: No value present</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对它进行map操作，我们发现即使为null，我们map方法的x.toString()并没有报错  可谓非常友好</span></span><br><span class="line">    <span class="comment">//Optional&lt;String&gt; s = Optional.&lt;String&gt;ofNullable(null).map(x -&gt; x.toString());</span></span><br><span class="line">    <span class="comment">//System.out.println(s); //Optional.empty</span></span><br><span class="line">    <span class="comment">//System.out.println(s.get()); //java.util.NoSuchElementException: No value present</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">////////////综上，我们可以经常这么来使用，可以很好的达到方法连缀的效果////////////</span></span><br><span class="line">    <span class="comment">//1、非常简单的三目运算符  如果是null，就返回1  否则返回里面的值</span></span><br><span class="line">    Integer v = Optional.&lt;Integer&gt;ofNullable(<span class="keyword">null</span>).orElse(<span class="number">1</span>);</span><br><span class="line">    System.out.println(v); <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、三目运算符  结合map  可以实现类型的转换 非常安全且强大</span></span><br><span class="line">    Integer vvv = Optional.&lt;String&gt;ofNullable(<span class="keyword">null</span>).map(x -&gt; Integer.valueOf(x)).orElse(<span class="number">100</span>);</span><br><span class="line">    System.out.println(vvv); <span class="comment">//100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p>Stream API 是把真正的函数式编程风格引入到 Java 中。其实简单来说可以把 Stream 理解为 MapReduce，当然 Google 的 MapReduce 的灵感也是来自函数式编程。它其实是一连串支持连续、并行聚集操作的元素。从语法上看，也很像 Linux 的管道、或者链式编程，代码写起来简洁明了，非常酷帅！</p>
<p>一个流式处理可以分为三个部分：转换成流、中间操作、终端操作。以集合为例，一个流式处理的操作我们首先需要调用 stream()函数将其转换成流，然后再调用相应的中间操作达到我们需要对集合进行的操作，比如筛选、转换等，最后通过终端操作对前面的结果进行封装，返回我们需要的形式。</p>
<h3 id="对流的操作概述"><a href="#对流的操作概述" class="headerlink" title="对流的操作概述"></a>对流的操作概述</h3><p>流的操作类型分为两种中间操作和终端操作。区分是不是中间操作基本看返回值是 <code>Stream&lt;T&gt;</code> 就是中间操作了。</p>
<h4 id="Intermediate（中间操作）"><a href="#Intermediate（中间操作）" class="headerlink" title="Intermediate（中间操作）"></a>Intermediate（中间操作）</h4><p>一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。</p>
<blockquote>
<p>map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered</p>
</blockquote>
<h4 id="Terminal（终端操作）"><a href="#Terminal（终端操作）" class="headerlink" title="Terminal（终端操作）"></a>Terminal（终端操作）</h4><p>一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。</p>
<blockquote>
<p>forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator</p>
</blockquote>
<h4 id="short-circuiting（短路操作）"><a href="#short-circuiting（短路操作）" class="headerlink" title="short-circuiting（短路操作）"></a>short-circuiting（短路操作）</h4><ul>
<li>对于一个 intermediate 操作，如果它接受的是一个无限流，它可以返回一个有限的新 Stream；</li>
<li>对于一个 terminal 操作，如果它接受的是一个无限流，但能在有限的时间计算出结果；</li>
</ul>
<blockquote>
<p>anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit</p>
</blockquote>
<h3 id="实例数据源"><a href="#实例数据源" class="headerlink" title="实例数据源"></a>实例数据源</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;PersonModel&gt; list = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        PersonModel wu = <span class="keyword">new</span> PersonModel(<span class="string">"wu qi"</span>, <span class="number">18</span>, <span class="string">"男"</span>);</span><br><span class="line">        PersonModel zhang = <span class="keyword">new</span> PersonModel(<span class="string">"zhang san"</span>, <span class="number">19</span>, <span class="string">"男"</span>);</span><br><span class="line">        PersonModel wang = <span class="keyword">new</span> PersonModel(<span class="string">"wang si"</span>, <span class="number">20</span>, <span class="string">"女"</span>);</span><br><span class="line">        PersonModel zhao = <span class="keyword">new</span> PersonModel(<span class="string">"zhao wu"</span>, <span class="number">20</span>, <span class="string">"男"</span>);</span><br><span class="line">        PersonModel chen = <span class="keyword">new</span> PersonModel(<span class="string">"chen liu"</span>, <span class="number">21</span>, <span class="string">"男"</span>);</span><br><span class="line">        list = Arrays.asList(wu, zhang, wang, zhao, chen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;PersonModel&gt; <span class="title">getData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p>Filter 会接受一个 Predicate 对象来过滤流中的元素，这个操作属于媒介操作，譬如可以在该操作之后调用另一个流操作(forEach)。ForEach 操作属于终止操作，接受一个 Consumer 对象来对于过滤之后的流中的每一个元素进行操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 过滤所有的男性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fiterSex</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;PersonModel&gt; data = Data.getData();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// old</span></span><br><span class="line">    List&lt;PersonModel&gt; temp=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (PersonModel person:data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"男"</span>.equals(person.getSex()))&#123;</span><br><span class="line">            temp.add(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(temp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new</span></span><br><span class="line">    List&lt;PersonModel&gt; collect = data</span><br><span class="line">            .stream()</span><br><span class="line">            .filter(person -&gt; <span class="string">"男"</span>.equals(person.getSex()))</span><br><span class="line">            .collect(toList());</span><br><span class="line">    System.out.println(collect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 过滤所有的男性 并且小于20岁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fiterSexAndAge</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;PersonModel&gt; data = Data.getData();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// old</span></span><br><span class="line">    List&lt;PersonModel&gt; temp=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (PersonModel person:data) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"男"</span>.equals(person.getSex())&amp;&amp;person.getAge()&lt;<span class="number">20</span>)&#123;</span><br><span class="line">            temp.add(person);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new 1</span></span><br><span class="line">    List&lt;PersonModel&gt; collect = data</span><br><span class="line">            .stream()</span><br><span class="line">            .filter(person -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"男"</span>.equals(person.getSex())&amp;&amp;person.getAge()&lt;<span class="number">20</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;)</span><br><span class="line">            .collect(toList());</span><br><span class="line">    <span class="comment">// new 2</span></span><br><span class="line">    List&lt;PersonModel&gt; collect1 = data</span><br><span class="line">            .stream()</span><br><span class="line">            .filter(person -&gt; (<span class="string">"男"</span>.equals(person.getSex())&amp;&amp;person.getAge()&lt;<span class="number">20</span>))</span><br><span class="line">            .collect(toList());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * stream 根据对象字段去重</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">Predicate&lt;T&gt; <span class="title">distinctByKey</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ?&gt; keyExtractor)</span> </span>&#123;</span><br><span class="line">    Set&lt;Object&gt; seen = ConcurrentHashMap.newKeySet();</span><br><span class="line">    <span class="keyword">return</span> t -&gt; seen.add(keyExtractor.apply(t));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * stream 根据对象字段去重 Demo</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">List&lt;PersonModel&gt; data = Data.getData();</span><br><span class="line">data.filter(distinctByKey(PersonModel::getId))</span><br><span class="line">    .forEach(person -&gt; &#123;</span><br><span class="line">        log.info(<span class="string">"&#123;&#125;"</span>, person);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>map 操作也是媒介操作的一种，可以通过给定的函数将每个元素映射到其他对象。下面的代码示例就是将所有的字符串转化为大写字符串。不过 map 操作是可以将任意对象转化为任意类型，流返回的泛型类型取决于传递给 map 的函数的返回值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取出所有的用户名字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getUserNameList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;PersonModel&gt; data = Data.getData();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// old</span></span><br><span class="line">    List&lt;String&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (PersonModel persion:data) &#123;</span><br><span class="line">        list.add(persion.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new 1</span></span><br><span class="line">    List&lt;String&gt; collect = data.stream().map(person -&gt; person.getName()).collect(toList());</span><br><span class="line">    System.out.println(collect);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new 2</span></span><br><span class="line">    List&lt;String&gt; collect1 = data.stream().map(PersonModel::getName).collect(toList());</span><br><span class="line">    System.out.println(collect1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// new 3</span></span><br><span class="line">    List&lt;String&gt; collect2 = data.stream().map(person -&gt; &#123;</span><br><span class="line">        System.out.println(person.getName());</span><br><span class="line">        <span class="keyword">return</span> person.getName();</span><br><span class="line">    &#125;).collect(toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="FlatMap"><a href="#FlatMap" class="headerlink" title="FlatMap"></a>FlatMap</h3><p>顾名思义，跟 map 差不多,更深层次的操作, Map 每个输入元素，都按照规则转换成为另外一个元素。还有一些场景，是一对多映射关系的，这时需要 flatMap。</p>
<p>map 和 flatMap 的区别：我个人认为，flatMap 的可以处理更深层次的数据，入参为多个 list，结果可以返回为一个 list，而 map 是一对一的，入参是多个 list，结果返回必须是多个 list。通俗的说，如果入参都是对象，那么 flatMap 可以操作对象里面的对象，而 map 只能操作第一层。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">flatMapString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;PersonModel&gt; data = Data.getData();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回类型不一样</span></span><br><span class="line">    List&lt;String&gt; collect = data.stream()</span><br><span class="line">            .flatMap(person -&gt; Arrays.stream(person.getName().split(<span class="string">" "</span>))).collect(toList());</span><br><span class="line"></span><br><span class="line">    List&lt;Stream&lt;String&gt;&gt; collect1 = data.stream()</span><br><span class="line">            .map(person -&gt; Arrays.stream(person.getName().split(<span class="string">" "</span>))).collect(toList());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用map实现</span></span><br><span class="line">    List&lt;String&gt; collect2 = data.stream()</span><br><span class="line">            .map(person -&gt; person.getName().split(<span class="string">" "</span>))</span><br><span class="line">            .flatMap(Arrays::stream).collect(toList());</span><br><span class="line">    <span class="comment">//另一种方式</span></span><br><span class="line">    List&lt;String&gt; collect3 = data.stream()</span><br><span class="line">            .map(person -&gt; person.getName().split(<span class="string">" "</span>))</span><br><span class="line">            .flatMap(str -&gt; Arrays.asList(str).stream()).collect(toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h3><p>该操作根据指定的方程对于流中的元素进行了指定的减少的操作。结果是 Optional 类型。类似递归，说不明白看图吧。</p>
<p><img src="/images/java/java8/reduce.png" alt="reduce"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reduceTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 累加，初始化值是 10</span></span><br><span class="line">    Integer reduce = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">            .reduce(<span class="number">10</span>, (count, item) -&gt;&#123;</span><br><span class="line">        System.out.println(<span class="string">"count:"</span>+count);</span><br><span class="line">        System.out.println(<span class="string">"item:"</span>+item);</span><br><span class="line">        <span class="keyword">return</span> count + item;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(reduce);</span><br><span class="line"></span><br><span class="line">    Integer reduce1 = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">            .reduce(<span class="number">0</span>, (x, y) -&gt; x + y);</span><br><span class="line">    System.out.println(reduce1);</span><br><span class="line"></span><br><span class="line">    String reduce2 = Stream.of(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>)</span><br><span class="line">            .reduce(<span class="string">"0"</span>, (x, y) -&gt; (x + <span class="string">","</span> + y));</span><br><span class="line">    System.out.println(reduce2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Collect"><a href="#Collect" class="headerlink" title="Collect"></a>Collect</h3><p>collect 在流中生成列表，map，等常用的数据结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * toList</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toListTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;PersonModel&gt; data = Data.getData();</span><br><span class="line">    List&lt;String&gt; collect = data.stream()</span><br><span class="line">            .map(PersonModel::getName)</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * toSet</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toSetTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;PersonModel&gt; data = Data.getData();</span><br><span class="line">    Set&lt;String&gt; collect = data.stream()</span><br><span class="line">            .map(PersonModel::getName)</span><br><span class="line">            .collect(Collectors.toSet());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * toMap</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toMapTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;PersonModel&gt; data = Data.getData();</span><br><span class="line">    Map&lt;String, Integer&gt; collect = data.stream()</span><br><span class="line">            .collect(</span><br><span class="line">                    Collectors.toMap(PersonModel::getName, PersonModel::getAge)</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line">    data.stream()</span><br><span class="line">            .collect(Collectors.toMap(per-&gt;per.getName(), value-&gt;&#123;</span><br><span class="line">        <span class="keyword">return</span> value+<span class="string">"1"</span>;</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指定类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toTreeSetTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;PersonModel&gt; data = Data.getData();</span><br><span class="line">    TreeSet&lt;PersonModel&gt; collect = data.stream()</span><br><span class="line">            .collect(Collectors.toCollection(TreeSet::<span class="keyword">new</span>));</span><br><span class="line">    System.out.println(collect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toGroupTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;PersonModel&gt; data = Data.getData();</span><br><span class="line">    Map&lt;Boolean, List&lt;PersonModel&gt;&gt; collect = data.stream()</span><br><span class="line">            .collect(Collectors.groupingBy(per -&gt; <span class="string">"男"</span>.equals(per.getSex())));</span><br><span class="line">    System.out.println(collect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分隔</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">toJoiningTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;PersonModel&gt; data = Data.getData();</span><br><span class="line">    String collect = data.stream()</span><br><span class="line">            .map(personModel -&gt; personModel.getName())</span><br><span class="line">            .collect(Collectors.joining(<span class="string">","</span>, <span class="string">"&#123;"</span>, <span class="string">"&#125;"</span>));</span><br><span class="line">    System.out.println(collect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reduce</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; collect = Stream.of(<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>).collect(</span><br><span class="line">            Collectors.reducing(<span class="keyword">new</span> ArrayList&lt;String&gt;(), x -&gt; Arrays.asList(x), (y, z) -&gt; &#123;</span><br><span class="line">                y.addAll(z);</span><br><span class="line">                <span class="keyword">return</span> y;</span><br><span class="line">            &#125;));</span><br><span class="line">    System.out.println(collect);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 转换成新对象</span></span><br><span class="line">List&lt;NewObj&gt; = oldObj.stream().collect(ArrayList::<span class="keyword">new</span>, (l, o) -&gt; &#123;</span><br><span class="line">    NewObj obj = <span class="keyword">new</span> NewObj()</span><br><span class="line">    obj.setName(o.getName());</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    l.add(obj);</span><br><span class="line">&#125;, List::addAll);</span><br></pre></td></tr></table></figure>

<h3 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h3><p>Java 8 提供了一些列的匹配的终止操作符来帮助开发者判断流当中的元素是否符合某些判断规则。所有的匹配类型的操作都会返回布尔类型。</p>
<ul>
<li><code>anyMatch</code> 表示，判断的条件里，任意一个元素成功，返回 true；</li>
<li><code>allMatch</code> 表示，判断条件里的元素，所有的都是，返回 true；</li>
<li><code>noneMatch</code> 跟 <code>allMatch</code> 相反，判断条件里的元素，所有的都不是，返回 true；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringCollection = Arrays.asList(<span class="string">"a"</span>, <span class="string">"a"</span>, <span class="string">"a"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> anyStartsWithA =</span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .anyMatch((s) -&gt; s.startsWith(<span class="string">"a"</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(anyStartsWithA);      <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> allStartsWithA =</span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .allMatch((s) -&gt; s.startsWith(<span class="string">"a"</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(allStartsWithA);      <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> noneStartsWithZ =</span><br><span class="line">    stringCollection</span><br><span class="line">        .stream()</span><br><span class="line">        .noneMatch((s) -&gt; s.startsWith(<span class="string">"z"</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(noneStartsWithZ);      <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>stream 替换成 parallelStream 或 parallel</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据数字的大小，有不同的结果</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> size = <span class="number">10000000</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"-----------List-----------"</span>);</span><br><span class="line">    testList();</span><br><span class="line">    System.out.println(<span class="string">"-----------Set-----------"</span>);</span><br><span class="line">    testSet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试list</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testList</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(size);</span><br><span class="line">    <span class="keyword">for</span> (Integer i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> Integer(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; temp1 = <span class="keyword">new</span> ArrayList&lt;&gt;(size);</span><br><span class="line">    <span class="comment">// old</span></span><br><span class="line">    <span class="keyword">long</span> start=System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (Integer i: list) &#123;</span><br><span class="line">        temp1.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(+System.currentTimeMillis()-start);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步</span></span><br><span class="line">    <span class="keyword">long</span> start1=System.currentTimeMillis();</span><br><span class="line">    list.stream().collect(Collectors.toList());</span><br><span class="line">    System.out.println(System.currentTimeMillis()-start1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并发</span></span><br><span class="line">    <span class="keyword">long</span> start2=System.currentTimeMillis();</span><br><span class="line">    list.parallelStream().collect(Collectors.toList());</span><br><span class="line">    System.out.println(System.currentTimeMillis()-start2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试set</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(size);</span><br><span class="line">    <span class="keyword">for</span> (Integer i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        list.add(<span class="keyword">new</span> Integer(i));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;Integer&gt; temp1 = <span class="keyword">new</span> HashSet&lt;&gt;(size);</span><br><span class="line">    <span class="comment">// old</span></span><br><span class="line">    <span class="keyword">long</span> start=System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (Integer i: list) &#123;</span><br><span class="line">        temp1.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(+System.currentTimeMillis()-start);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同步</span></span><br><span class="line">    <span class="keyword">long</span> start1=System.currentTimeMillis();</span><br><span class="line">    list.stream().collect(Collectors.toSet());</span><br><span class="line">    System.out.println(System.currentTimeMillis()-start1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并发</span></span><br><span class="line">    <span class="keyword">long</span> start2=System.currentTimeMillis();</span><br><span class="line">    list.parallelStream().collect(Collectors.toSet());</span><br><span class="line">    System.out.println(System.currentTimeMillis()-start2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">        list.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    Integer a = <span class="number">1000</span>;</span><br><span class="line">    <span class="comment">//无顺序的打印</span></span><br><span class="line">    list.parallelStream().filter(mm -&gt; mm &lt; <span class="number">1000</span>).forEach(System.out::println);</span><br><span class="line">    <span class="comment">//按list原有的顺序输出。collect(Collectors.toList())后得到的集合是按原来的顺序输出的</span></span><br><span class="line">    list.parallelStream().filter(mm -&gt; !a.equals(mm)).collect(Collectors.toList()).forEach(System.out::println);</span><br><span class="line">    <span class="comment">//stream().parallel()与parallelStream()效果一样，都会无顺序的打印</span></span><br><span class="line">    list.stream().parallel().forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 批量操作，分割集合</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> oriList    要分割的集合</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> size       每批处理大小</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> isParallel 是否启用并行流</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &lt;T&gt;        数据类型</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> 分割后的集合</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;List&lt;T&gt;&gt; splitList(List&lt;T&gt; oriList, <span class="keyword">int</span> size, <span class="keyword">boolean</span> isParallel) &#123;</span><br><span class="line">    <span class="comment">// 未达到批量上限，不做分割处理</span></span><br><span class="line">    <span class="keyword">if</span> (oriList.size() &lt;= size) &#123;</span><br><span class="line">        List&lt;List&lt;T&gt;&gt; splitList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        splitList.add(oriList);</span><br><span class="line">        <span class="keyword">return</span> splitList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算分割数量</span></span><br><span class="line">    <span class="keyword">int</span> limit = (oriList.size() + size - <span class="number">1</span>) / size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并行流处理分割</span></span><br><span class="line">    <span class="keyword">if</span> (isParallel) &#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">1</span>)</span><br><span class="line">            .limit(limit)</span><br><span class="line">            .parallel()</span><br><span class="line">            .map(a -&gt; oriList.stream()</span><br><span class="line">                .skip(a * size)</span><br><span class="line">                .limit(size)</span><br><span class="line">                .parallel()</span><br><span class="line">                .collect(Collectors.toList()))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;List&lt;T&gt;&gt; splitList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">1</span>).limit(limit).forEach(i -&gt; &#123;</span><br><span class="line">            splitList.add(oriList.stream().skip(i * size).limit(size).collect(Collectors.toList()));</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> splitList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="peek（调试）"><a href="#peek（调试）" class="headerlink" title="peek（调试）"></a>peek（调试）</h3><p>通过 peek 可以查看每个值，同时能继续操作流</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">peekTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;PersonModel&gt; data = Data.getData();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//peek打印出遍历的每个per</span></span><br><span class="line">    data.stream().map(per-&gt;per.getName()).peek(p-&gt;&#123;</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;).collect(toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * forEach 增强</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> startIndex 开始遍历的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> elements   集合</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> action</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(<span class="keyword">int</span> startIndex, Iterable&lt;? extends T&gt; elements, BiConsumer&lt;Integer, ? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(elements);</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">if</span> (startIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        startIndex = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (T element : elements) &#123;</span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">if</span> (index &lt;= startIndex) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        action.accept(index - <span class="number">1</span>, element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 统计集合中每个元素出现的所有位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, List&lt;Integer&gt;&gt; getElementPositions(List&lt;String&gt; list) &#123;</span><br><span class="line">    Map&lt;String, List&lt;Integer&gt;&gt; positionsMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">        positionsMap.computeIfAbsent(list.get(i), k -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1</span>)).add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> positionsMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"><span class="keyword">import</span> java.util.function.BiConsumer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Iterable 的工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Iterables</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            Iterable&lt;? extends E&gt; elements, BiConsumer&lt;Integer, ? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(elements);</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (E element : elements) &#123;</span><br><span class="line">            action.accept(index++, element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用 Iterables.forEach 改写 getElementPositions方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;String, List&lt;Integer&gt;&gt; getElementPositions(List&lt;String&gt; list) &#123;</span><br><span class="line">    Map&lt;String, List&lt;Integer&gt;&gt; positionsMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Iterables.forEach(list, (index, str) -&gt; &#123;</span><br><span class="line">        positionsMap.computeIfAbsent(str, k -&gt; <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">1</span>)).add(index);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> positionsMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"c"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"d"</span>, <span class="string">"d"</span>, <span class="string">"f"</span>, <span class="string">"f"</span>, <span class="string">"g"</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"使用 computeIfAbsent 和 Iterable.forEach："</span>);</span><br><span class="line">    Map&lt;String, List&lt;Integer&gt;&gt; elementPositions = getElementPositions(list);</span><br><span class="line">    System.out.println(elementPositions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/winterbe/java8-tutorial" target="_blank" rel="noopener">java8 tutorial</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html" target="_blank" rel="noopener">java8 stream</a></li>
<li><a href="https://www.jianshu.com/p/9fe8632d0bc2" target="_blank" rel="noopener">java8-Stream 集合操作快速上手</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
              <a href="/tags/java8/" rel="tag"># java8</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/back-end/docker/docker-gitlab/" rel="prev" title="使用 Docker 搭建 GitLab CE 实现 CI">
      <i class="fa fa-chevron-left"></i> 使用 Docker 搭建 GitLab CE 实现 CI
    </a></div>
      <div class="post-nav-item">
    <a href="/back-end/java/abstract-interface/" rel="next" title="抽象类和接口">
      抽象类和接口 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Lambda-表达式"><span class="nav-number">1.</span> <span class="nav-text">Lambda 表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Functional-Interfaces"><span class="nav-number">2.</span> <span class="nav-text">Functional Interfaces</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Built-in-Functional-Interfaces"><span class="nav-number">2.1.</span> <span class="nav-text">Built-in Functional Interfaces</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Suppliers"><span class="nav-number">2.2.</span> <span class="nav-text">Suppliers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Consumers"><span class="nav-number">2.3.</span> <span class="nav-text">Consumers</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Predicates"><span class="nav-number">2.4.</span> <span class="nav-text">Predicates</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Functions"><span class="nav-number">2.5.</span> <span class="nav-text">Functions</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Operator"><span class="nav-number">2.6.</span> <span class="nav-text">Operator</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Method-and-Constructor-References"><span class="nav-number">3.</span> <span class="nav-text">Method and Constructor References</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Lambda-Scopes"><span class="nav-number">4.</span> <span class="nav-text">Lambda Scopes</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Accessing-local-variables"><span class="nav-number">4.1.</span> <span class="nav-text">Accessing local variables</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Accessing-fields-and-static-variables"><span class="nav-number">4.2.</span> <span class="nav-text">Accessing fields and static variables</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Accessing-Default-Interface-Methods"><span class="nav-number">4.3.</span> <span class="nav-text">Accessing Default Interface Methods</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Lambda-表达式里面给外部变量赋值的问题"><span class="nav-number">4.4.</span> <span class="nav-text">Lambda 表达式里面给外部变量赋值的问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Default-Methods-for-Interfaces"><span class="nav-number">5.</span> <span class="nav-text">Default Methods for Interfaces</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Annotations"><span class="nav-number">6.</span> <span class="nav-text">Annotations</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#扩展注解的支持（类型注解）"><span class="nav-number">7.</span> <span class="nav-text">扩展注解的支持（类型注解）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JavaScript-引擎-Nashorn"><span class="nav-number">8.</span> <span class="nav-text">JavaScript 引擎 Nashorn</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Base64"><span class="nav-number">9.</span> <span class="nav-text">Base64</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Date-Time-API-JSR-310"><span class="nav-number">10.</span> <span class="nav-text">Date&#x2F;Time API (JSR 310)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Clock"><span class="nav-number">10.1.</span> <span class="nav-text">Clock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Timezones"><span class="nav-number">10.2.</span> <span class="nav-text">Timezones</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LocalTime"><span class="nav-number">10.3.</span> <span class="nav-text">LocalTime</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LocalDate"><span class="nav-number">10.4.</span> <span class="nav-text">LocalDate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LocalDateTime"><span class="nav-number">10.5.</span> <span class="nav-text">LocalDateTime</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Optional"><span class="nav-number">11.</span> <span class="nav-text">Optional</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#创建一个-Optional"><span class="nav-number">11.1.</span> <span class="nav-text">创建一个 Optional</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#get-与-isPresent"><span class="nav-number">11.2.</span> <span class="nav-text">get 与 isPresent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ifPresent"><span class="nav-number">11.3.</span> <span class="nav-text">ifPresent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#filter"><span class="nav-number">11.4.</span> <span class="nav-text">filter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#orElse-与-orElseThrow"><span class="nav-number">11.5.</span> <span class="nav-text">orElse 与 orElseThrow</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#map-与-flatMap-函数隆重登场"><span class="nav-number">11.6.</span> <span class="nav-text">map 与 flatMap 函数隆重登场</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代替三目运算"><span class="nav-number">11.7.</span> <span class="nav-text">代替三目运算</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Stream"><span class="nav-number">12.</span> <span class="nav-text">Stream</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#对流的操作概述"><span class="nav-number">12.1.</span> <span class="nav-text">对流的操作概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Intermediate（中间操作）"><span class="nav-number">12.1.1.</span> <span class="nav-text">Intermediate（中间操作）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Terminal（终端操作）"><span class="nav-number">12.1.2.</span> <span class="nav-text">Terminal（终端操作）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#short-circuiting（短路操作）"><span class="nav-number">12.1.3.</span> <span class="nav-text">short-circuiting（短路操作）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例数据源"><span class="nav-number">12.2.</span> <span class="nav-text">实例数据源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Filter"><span class="nav-number">12.3.</span> <span class="nav-text">Filter</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map"><span class="nav-number">12.4.</span> <span class="nav-text">Map</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FlatMap"><span class="nav-number">12.5.</span> <span class="nav-text">FlatMap</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reduce"><span class="nav-number">12.6.</span> <span class="nav-text">Reduce</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Collect"><span class="nav-number">12.7.</span> <span class="nav-text">Collect</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Match"><span class="nav-number">12.8.</span> <span class="nav-text">Match</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#并发"><span class="nav-number">12.9.</span> <span class="nav-text">并发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#peek（调试）"><span class="nav-number">12.10.</span> <span class="nav-text">peek（调试）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#forEach"><span class="nav-number">12.11.</span> <span class="nav-text">forEach</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">13.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Richard"
      src="https://avatars3.githubusercontent.com/u/18113256?v=3&s=460">
  <p class="site-author-name" itemprop="name">Richard</p>
  <div class="site-description" itemprop="description">惶者生存，偏执者成功</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">132</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">59</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xinlc" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xinlc" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/xinlc" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;xinlc" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://learnxinyminutes.com/" title="https:&#x2F;&#x2F;learnxinyminutes.com" rel="noopener" target="_blank">Learn X in Y minutes</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://justjavac.com/" title="http:&#x2F;&#x2F;justjavac.com" rel="noopener" target="_blank">justjavac</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.ruanyifeng.com/blog/" title="http:&#x2F;&#x2F;www.ruanyifeng.com&#x2F;blog&#x2F;" rel="noopener" target="_blank">阮一峰</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.liaoxuefeng.com/" title="https:&#x2F;&#x2F;www.liaoxuefeng.com" rel="noopener" target="_blank">廖雪峰</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://tech.meituan.com/" title="https:&#x2F;&#x2F;tech.meituan.com" rel="noopener" target="_blank">美团技术</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.v2ex.com/" title="https:&#x2F;&#x2F;www.v2ex.com" rel="noopener" target="_blank">V2EX</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://caniuse.com/" title="https:&#x2F;&#x2F;caniuse.com" rel="noopener" target="_blank">caniuse/工具</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.css88.com/nav/" title="http:&#x2F;&#x2F;www.css88.com&#x2F;nav&#x2F;" rel="noopener" target="_blank">css88/doc</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://overapi.com/" title="http:&#x2F;&#x2F;overapi.com&#x2F;" rel="noopener" target="_blank">OverAPI/api</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://devdocs.io/" title="http:&#x2F;&#x2F;devdocs.io&#x2F;" rel="noopener" target="_blank">DevDocs/api</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://tool.oschina.net/" title="http:&#x2F;&#x2F;tool.oschina.net&#x2F;" rel="noopener" target="_blank">在线工具/索引</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://tool.lu/" title="http:&#x2F;&#x2F;tool.lu&#x2F;" rel="noopener" target="_blank">ToolBox</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://hao.shejidaren.com/" title="http:&#x2F;&#x2F;hao.shejidaren.com&#x2F;" rel="noopener" target="_blank">设计导航</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Richard</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>














  

  

</body>
</html>
