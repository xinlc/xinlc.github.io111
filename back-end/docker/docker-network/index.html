<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico">
  <link rel="mask-icon" href="/favicon.ico" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.lichao.xin","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"appID":"3ZZ8ITB7HE","apiKey":"062eb5a54afbcbf3f20452d58fc40035","indexName":"xinlc","hits":{"per_page":10},"labels":{"input_placeholder":"搜索","hits_empty":"未发现与「${query}」相关的内容","hits_stats":"${hits} 条相关条目，使用了 ${time} 毫秒"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Docker 允许通过外部访问容器或容器互联的方式来提供网络服务。">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker 之 网络配置">
<meta property="og:url" content="https://blog.lichao.xin/back-end/docker/docker-network/index.html">
<meta property="og:site_name" content="Richard Xin&#39;s Blog">
<meta property="og:description" content="Docker 允许通过外部访问容器或容器互联的方式来提供网络服务。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog.lichao.xin/images/docker/docker-network/1.jpg">
<meta property="og:image" content="https://blog.lichao.xin/images/docker/docker-network/2.jpg">
<meta property="og:image" content="https://blog.lichao.xin/images/docker/docker-network/3.jpg">
<meta property="og:image" content="https://blog.lichao.xin/images/docker/docker-network/4.jpg">
<meta property="article:published_time" content="2019-11-12T17:57:00.000Z">
<meta property="article:modified_time" content="2021-06-14T01:33:22.383Z">
<meta property="article:author" content="Richard">
<meta property="article:tag" content="docker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog.lichao.xin/images/docker/docker-network/1.jpg">

<link rel="canonical" href="https://blog.lichao.xin/back-end/docker/docker-network/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Docker 之 网络配置 | Richard Xin's Blog</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4530ac9d0bc4e258535c4a9b17029f0c";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Richard Xin's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Richard Xin's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Quick notes</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">132</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">59</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">12</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.lichao.xin/back-end/docker/docker-network/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://avatars3.githubusercontent.com/u/18113256?v=3&s=460">
      <meta itemprop="name" content="Richard">
      <meta itemprop="description" content="惶者生存，偏执者成功">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Richard Xin's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Docker 之 网络配置
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-11-12 17:57:00" itemprop="dateCreated datePublished" datetime="2019-11-12T17:57:00+00:00">2019-11-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-06-14 01:33:22" itemprop="dateModified" datetime="2021-06-14T01:33:22+00:00">2021-06-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>Docker 允许通过外部访问容器或容器互联的方式来提供网络服务。</p>
<a id="more"></a>

<h2 id="外部访问容器"><a href="#外部访问容器" class="headerlink" title="外部访问容器"></a>外部访问容器</h2><p>容器中运行一些网络应用，要让外部也可以访问这些应用，可以通过 <code>-P</code> 或 <code>-p</code> 参数来指定端口映射。</p>
<p>当使用 <code>-P</code> 标记时，Docker 会随机映射一个 <code>49000~49900</code> 的端口到内部容器开放的网络端口。</p>
<p>使用 <code>docker container ls</code> 可以看到，本地主机的 <code>32768</code> 被映射到了容器的 <code>5000</code> 端口。访问本机的 <code>32768</code> 端口即可访问容器内 web 应用提供的界面。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P training/webapp python app.py</span><br><span class="line"></span><br><span class="line">$ docker container ls -l</span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS                     NAMES</span><br><span class="line">2c9576031bc8        training/webapp     <span class="string">"python app.py"</span>     29 seconds ago      Up 27 seconds       0.0.0.0:32768-&gt;5000/tcp   goofy_meitner</span><br></pre></td></tr></table></figure>

<p>-p 则可以指定要映射的端口，并且，在一个指定端口上只可以绑定一个容器。支持的格式有 <code>ip:hostPort:containerPort | ip::containerPort | hostPort:containerPort</code>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 映射所有接口地址</span></span><br><span class="line"><span class="comment"># 使用 hostPort:containerPort 格式本地的 5000 端口映射到容器的 5000 端口，可以执行</span></span><br><span class="line">$ docker run --rm -p 5000:5000 training/webapp python app.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 映射到指定地址的指定端口</span></span><br><span class="line"><span class="comment"># 使用 ip:hostPort:containerPort 格式指定映射使用一个特定地址，比如 localhost 地址 127.0.0.1</span></span><br><span class="line">$ docker run --rm -p 127.0.0.1:5000:5000 training/webapp python app.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 映射到指定地址的任意端口</span></span><br><span class="line"><span class="comment"># 使用 ip::containerPort 绑定 localhost 的任意端口到容器的 5000 端口，本地主机会自动分配一个端口。</span></span><br><span class="line">$ docker run --rm -p 127.0.0.1::5000 training/webapp python app.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还可以使用 udp 标记来指定 udp 端口</span></span><br><span class="line">$ docker run --rm -p 127.0.0.1:5000:5000/udp training/webapp python app.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看映射端口配置</span></span><br><span class="line"><span class="comment"># 使用 docker port 来查看当前映射的端口配置，也可以查看到绑定的地址</span></span><br><span class="line">$ docker port goofy_meitner 5000</span><br><span class="line">0.0.0.0:32768</span><br><span class="line"></span><br><span class="line"><span class="comment"># -p 标记可以多次使用来绑定多个端口</span></span><br><span class="line">$ docker run --rm \</span><br><span class="line">    -p 5000:5000 \</span><br><span class="line">    -p 3000:80 \</span><br><span class="line">    training/webapp \</span><br><span class="line">    python app.py</span><br></pre></td></tr></table></figure>

<h2 id="Docker-的网络模式"><a href="#Docker-的网络模式" class="headerlink" title="Docker 的网络模式"></a>Docker 的网络模式</h2><p>目前 Docker 支持以下网络模式。</p>
<table>
<thead>
<tr>
<th align="left">模式</th>
<th align="center">是否支持跨主机</th>
<th align="left">南北向通信机制</th>
<th align="right">东西向通信机制</th>
</tr>
</thead>
<tbody><tr>
<td align="left">bridge</td>
<td align="center">否</td>
<td align="left">宿主机端口绑定</td>
<td align="right">通过 Linux bridge</td>
</tr>
<tr>
<td align="left">host</td>
<td align="center">是</td>
<td align="left">按宿主机网络通信</td>
<td align="right">按宿主机网络通信</td>
</tr>
<tr>
<td align="left">container</td>
<td align="center">否</td>
<td align="left">宿主机端口绑定</td>
<td align="right">通过 link 通信</td>
</tr>
<tr>
<td align="left">overlay</td>
<td align="center">是</td>
<td align="left">基于 bridge 网络模型，使用 docker_gwbridge</td>
<td align="right">隧道传输，基于 vxlan 协议的网络实现</td>
</tr>
<tr>
<td align="left">macvlan</td>
<td align="center">是</td>
<td align="left">基于 linux kernel 模块</td>
<td align="right">基于 linux kernel 模块</td>
</tr>
<tr>
<td align="left">none</td>
<td align="center">否</td>
<td align="left">无法通信</td>
<td align="right">需要手动为 Docker 容器添加网卡、配置 IP 等，如使用: <a href="https://github.com/jpetazzo/pipework" target="_blank" rel="noopener">pipework</a> 工具</td>
</tr>
</tbody></table>
<h2 id="bridge"><a href="#bridge" class="headerlink" title="bridge"></a>bridge</h2><p>bridge 模式，使用 <code>--network=bridge</code> 指定，默认设置。</p>
<p>这是 Dokcer 网络的默认设置，为容器创建独立的网络命名空间，容器具有独立的网卡等所有单独的网络栈，是最常用的使用方式。在 <code>docker run</code> 启动容器的时候，如果不加 <code>--network</code> 参数，就默认采用这种网络模式。</p>
<p>安装完 Docker，系统会自动添加一个供 Docker 使用的网桥 <code>docker0</code>，我们创建一个新的容器时，容器通过 <code>DHCP</code> 获取一个与 <code>docker0</code> 同网段的 IP 地址，并默认连接到 <code>docker0</code> 网桥，容器和 <code>docker0</code> 之间通过 <code>veth</code> 进行连接，<code>veth</code> 相当于一根虚拟网线，连接容器和虚拟交换机，以此实现容器与宿主机的网络互通。网络结构如下图：</p>
<p><img src="/images/docker/docker-network/1.jpg" alt="1"></p>
<h3 id="使用-bridge"><a href="#使用-bridge" class="headerlink" title="使用 bridge"></a>使用 bridge</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 bridge 自定义网络</span></span><br><span class="line">docker network create -d bridge my-net</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行一个容器并连接到新建的 my-net 网络</span></span><br><span class="line">docker run -it --rm --name busybox1 --network my-net busybox sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开新的终端，再运行一个容器并加入到 my-net 网络</span></span><br><span class="line">docker run -it --rm --name busybox2 --network my-net busybox sh</span><br></pre></td></tr></table></figure>

<p>再打开一个新的终端查看容器信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker container ls</span><br><span class="line"></span><br><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">dc4761e5cbf0        busybox             <span class="string">"sh"</span>                40 seconds ago      Up 39 seconds                           busybox2</span><br><span class="line">3a1bcbabeb63        busybox             <span class="string">"sh"</span>                47 seconds ago      Up 46 seconds                           busybox1</span><br></pre></td></tr></table></figure>

<p>下面通过 ping 来证明 busybox1 容器和 busybox2 容器建立了互联关系。</p>
<p>在 busybox1 容器内 <code>ping busybox2</code>，查看是否可以连通。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/ <span class="comment"># ping busybox2</span></span><br><span class="line">PING busybox2 (172.18.0.3): 56 data bytes</span><br><span class="line">64 bytes from 172.18.0.3: seq=0 ttl=64 time=0.176 ms</span><br><span class="line">64 bytes from 172.18.0.3: seq=1 ttl=64 time=0.228 ms</span><br></pre></td></tr></table></figure>

<p>容器的访问控制，主要通过 Linux 上的 iptables 防火墙来进行管理和实现。可以运行 <code>iptables -t nat -L -n</code> 查看。</p>
<h2 id="host"><a href="#host" class="headerlink" title="host"></a>host</h2><p>host 模式，使用 <code>--network=host</code> 指定。</p>
<p>Docker 使用了 Linux 的 <code>Namespaces</code> 技术来进行资源隔离，如 <code>PID Namespace</code> 隔离进程，<code>Mount Namespace</code> 隔离文件系统，<code>Network Namespace</code> 隔离网络等。一个 <code>Network Namespace</code> 提供了一份独立的网络环境，包括网卡、路由、Iptable 规则等都与其他的 <code>Network Namespace</code>隔离。</p>
<p>一个 Docker 容器一般会分配一个独立的 <code>Network Namespace</code>。但如果启动容器的时候使用 <code>host</code> 模式，那么这个容器将不会获得一个独立的 <code>Network Namespace</code>，而是和宿主机共用一个 <code>Network Namespace</code>。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。就和直接跑在宿主机中一样。但是容器的文件系统、进程列表等还是和宿主机隔离的。</p>
<h3 id="使用-host"><a href="#使用-host" class="headerlink" title="使用 host"></a>使用 host</h3><p>host 模式只支持 Linux 宿主机，Mac 下是不好用的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 此时会 web 容器会占用主机 80 端口，可以访问 http://localhost/</span></span><br><span class="line">$ docker run --rm --name web --network host nginx</span><br></pre></td></tr></table></figure>

<h2 id="container-link"><a href="#container-link" class="headerlink" title="container link"></a>container link</h2><blockquote>
<p>注意：官方已不建议使用。</p>
</blockquote>
<p>container 模式，使用 <code>--link=NAME_or_ID:alias</code> 指定。</p>
<p>这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡与配置 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他方面仍然是隔离的。两个容器的进程可以通过 lo 网卡设备通信。</p>
<h3 id="使用-link"><a href="#使用-link" class="headerlink" title="使用 link"></a>使用 link</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行一个容器</span></span><br><span class="line">docker run -it --rm --name busybox1 busybox sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开新的终端，再运行一个容器并连接 busybox1</span></span><br><span class="line">docker run -it --rm --name busybox2 --link busybox1:busybox1 busybox sh</span><br></pre></td></tr></table></figure>

<p><code>--link</code> Docker 通过更新容器内的环境变量和 <code>/etc/hosts</code> 实现。</p>
<h2 id="overlay"><a href="#overlay" class="headerlink" title="overlay"></a>overlay</h2><p>overlay 适用于 Docker 宿主机集群中的各个独立的容器实例之间通信。为集群中的 Docker 容器实例提供跨多个 Docker 引擎的网络连接。</p>
<p>它是 <code>docker swarm</code> 内置的跨主机通信方案，这是一个基于 VXLAN（VXLAN 可以封装 L2 L3，协议数据，是一种隧道协议） 协议的网络实现，其作用是虚拟出一个子网，让处于不同主机的容器能透明地使用这个子网。所以跨主机的容器通信就变成了在同一个子网下的容器通信，看上去就像是同一主机下的 bridge 网络通信。</p>
<p>分析 <code>docker swarm</code> 网络原理，这里省略创建 swarm 集群，改天另开一篇。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ docker network ls</span><br><span class="line">NETWORK ID          NAME                   DRIVER              SCOPE</span><br><span class="line">sulgilqz97bb        backend_default        overlay             swarm</span><br><span class="line">716ix1fud0xg        frontend_default       overlay             swarm</span><br><span class="line">eaae518b7597        bridge                 bridge              <span class="built_in">local</span></span><br><span class="line">6e97040883d2        docker_gwbridge        bridge              <span class="built_in">local</span></span><br><span class="line">c4e4b65234d9        host                   host                <span class="built_in">local</span></span><br><span class="line">04138ihk9hft        ingress                overlay             swarm</span><br><span class="line">0fdddcabdca4        none                   null                <span class="built_in">local</span></span><br></pre></td></tr></table></figure>

<p>其中 ingress 为 docker 默认的 overlay 网络。</p>
<p>查看 ingress 网络信息 <code>docker network inspect ingress</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"Name"</span>: <span class="string">"ingress"</span>,</span><br><span class="line">        <span class="string">"Id"</span>: <span class="string">"04138ihk9hfteejpile2owxl1"</span>,</span><br><span class="line">        <span class="string">"Created"</span>: <span class="string">"2019-11-15T18:17:59.286511557+08:00"</span>,</span><br><span class="line">        <span class="string">"Scope"</span>: <span class="string">"swarm"</span>,</span><br><span class="line">        <span class="string">"Driver"</span>: <span class="string">"overlay"</span>,</span><br><span class="line">        <span class="string">"EnableIPv6"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"IPAM"</span>: &#123;</span><br><span class="line">            <span class="string">"Driver"</span>: <span class="string">"default"</span>,</span><br><span class="line">            <span class="string">"Options"</span>: null,</span><br><span class="line">            <span class="string">"Config"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="string">"Subnet"</span>: <span class="string">"10.0.0.0/24"</span>,</span><br><span class="line">                    <span class="string">"Gateway"</span>: <span class="string">"10.0.0.1"</span></span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Internal"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"Attachable"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"Ingress"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"ConfigFrom"</span>: &#123;</span><br><span class="line">            <span class="string">"Network"</span>: <span class="string">""</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"ConfigOnly"</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="string">"Containers"</span>: &#123;</span><br><span class="line">            <span class="string">"ingress-sbox"</span>: &#123;</span><br><span class="line">                <span class="string">"Name"</span>: <span class="string">"ingress-endpoint"</span>,</span><br><span class="line">                <span class="string">"EndpointID"</span>: <span class="string">"4ee0d0dae472c42b9830d5e75439e27457fd49a529861d8d8c1327dc9bb5f1c9"</span>,</span><br><span class="line">                <span class="string">"MacAddress"</span>: <span class="string">"02:42:0a:00:00:02"</span>,</span><br><span class="line">                <span class="string">"IPv4Address"</span>: <span class="string">"10.0.0.2/24"</span>,</span><br><span class="line">                <span class="string">"IPv6Address"</span>: <span class="string">""</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Options"</span>: &#123;</span><br><span class="line">            <span class="string">"com.docker.network.driver.overlay.vxlanid_list"</span>: <span class="string">"4096"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"Labels"</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">"Peers"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"Name"</span>: <span class="string">"085cc36f1096"</span>,</span><br><span class="line">                <span class="string">"IP"</span>: <span class="string">"192.168.0.80"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"Name"</span>: <span class="string">"8eef30a2b4f4"</span>,</span><br><span class="line">                <span class="string">"IP"</span>: <span class="string">"192.168.0.79"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"Name"</span>: <span class="string">"c3637240ae66"</span>,</span><br><span class="line">                <span class="string">"IP"</span>: <span class="string">"192.168.0.78"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>由于 orverlay 网络模型是基于 vxlan 协议的网络实现，所以根据上面的网络信息可知，它是要在三层网络中虚拟出二层网络，即跨网段建立虚拟子网，也就是把 docker 要发送的信息先发送到虚拟子网地址 <code>10.0.0.1</code>，再由虚拟子网包装为宿主机的真实网网址 <code>192.168.0.80</code>，这样做的好处就是不会公开暴露容器的端口，让这些事情交给 overlay 网络驱动去做就行了，而且在同一台服务器，不会引起端口冲突，最重要的一点是可以实现集群容器间的负载均衡。</p>
<p><img src="/images/docker/docker-network/2.jpg" alt="overlay xval"></p>
<p>正如它的名字一样，在所有容器的上面一层，覆盖了一层网络（所有 overlay 在每个 host 都会有一份），该网络可以使在集群中的容器像本地通信一样，所以 orverlay 网络模型也称之为覆盖网络。</p>
<p>docker 使用vxlan 封装的网络拓扑是怎么样的？</p>
<p>如下图，使用 <code>docker_gwbridge</code> 进行容器内部通信，以及外部通信， 使用ovnet 进行overlay 专有网段通信</p>
<p><img src="/images/docker/docker-network/3.jpg" alt="docker_gwbridge"></p>
<p>ovnet overlay network 结构是怎么样的？</p>
<p><img src="/images/docker/docker-network/4.jpg" alt="ovnet namespace"></p>
<p>如果有多个 overlay ，每个 overlay 使用不同的 <code>vxlan id</code> 来标识，每个单独的 overlay 链接到 ovnet 命名空间中不同的 bridge 设备。通过 bridge 设备转发数据到 vxlan 设备，vxlan 设备对数据进行封装（加vxlan header 等）后，转发（arp proxy）数据到主机中，主机网络将数据发出。</p>
<p>通过查看 nat 转发规则可以看到相关端口已经转发到了 docker_gwbridge 上：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看路由</span></span><br><span class="line">route</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 nat</span></span><br><span class="line">iptables -t nat -L -n</span><br></pre></td></tr></table></figure>

<h3 id="构建自定义-overlay-网络集群"><a href="#构建自定义-overlay-网络集群" class="headerlink" title="构建自定义 overlay 网络集群"></a>构建自定义 overlay 网络集群</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新建网络</span></span><br><span class="line">$ docker network create -d overlay my-overlay-net</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 etcd 服务</span></span><br><span class="line">$ docker service create \</span><br><span class="line">              --name etcd \</span><br><span class="line">              --replicas 2 \</span><br><span class="line">              --publish published=8080,target=8080 \</span><br><span class="line">              --network my-overlay-net \</span><br><span class="line">              etcd:latest</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建mysql 服务</span></span><br><span class="line">$ docker service create \</span><br><span class="line">              --name mysql \</span><br><span class="line">              --replicas 2 \</span><br><span class="line">              --publish published=3306,target=3306 \</span><br><span class="line">              --network my-overlay-net \</span><br><span class="line">              mysql:5.7</span><br></pre></td></tr></table></figure>

<h2 id="macvlan"><a href="#macvlan" class="headerlink" title="macvlan"></a>macvlan</h2><p>macvlan 本身是 <code>Linxu kernel</code> 的模块，本质上是一种网卡虚拟化技术。其功能是允许在同一个物理网卡上虚拟出多个网卡，通过不同的MAC地址在数据链路层进行网络数据的转发，一块网卡上配置多个 MAC 地址（即多个 interface），每个 interface 可以配置自己的 IP，Docker 的 macvlan 网络实际上就是使用了 Linux 提供的 macvlan 驱动。</p>
<h3 id="使用-macvaln"><a href="#使用-macvaln" class="headerlink" title="使用 macvaln"></a>使用 macvaln</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#检查 是否支持 macvlan</span></span><br><span class="line">modprobe macvlan</span><br><span class="line">lsmod | grep macvlan</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启网卡混杂模式 promiscuity=1 on</span></span><br><span class="line">ip -d link show eth1 | grep promisc</span><br><span class="line"><span class="comment"># ip link set [interface] promisc on</span></span><br><span class="line">ip link <span class="built_in">set</span> eth0 promisc on;</span><br><span class="line">ifconfig eth0 promisc</span><br><span class="line"></span><br><span class="line">ip netns add net1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看eth0 网卡地址</span></span><br><span class="line">ifconfig eth0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建的格式为 ip link add link &lt;PARENT&gt; &lt;NAME&gt; type macvlan，</span></span><br><span class="line"><span class="comment"># 其中 &lt;PARENT&gt; 是 macvlan 接口的父 interface 名称，&lt;NAME&gt; 是新建的 macvlan 接口的名称，这个名字可以任意取。</span></span><br><span class="line"><span class="comment"># 使用 ip link 可以看到我们刚创建的 macvlan 接口，除了它自己的名字之外，后面还跟着父接口的名字</span></span><br><span class="line"><span class="comment"># 使用 bridge 模式，没加这个 默认net1，net2 没有ping 通</span></span><br><span class="line">ip link add link eth0 mac1 <span class="built_in">type</span> macvlan mode bridge</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">ip -d link show mac1</span><br><span class="line"></span><br><span class="line">ip link <span class="built_in">set</span> mac1 netns net1</span><br><span class="line"><span class="comment"># 与 eth0 网段相同</span></span><br><span class="line">ip netns <span class="built_in">exec</span> net1 ip addr add 10.0.2.21/24 dev mac1</span><br><span class="line"></span><br><span class="line">ip netns <span class="built_in">exec</span> net1 ip link <span class="built_in">set</span> mac1 up</span><br><span class="line">ip netns <span class="built_in">exec</span> net1 ip a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加默认路由,与主机eth0 默认路由一致</span></span><br><span class="line">ip netns <span class="built_in">exec</span> net1 route add default gw 10.0.2.2</span><br><span class="line"></span><br><span class="line">ip netns add net2</span><br><span class="line">ip link add link eth0 mac2 <span class="built_in">type</span> macvlan</span><br><span class="line">ip link <span class="built_in">set</span> mac2 netns net2</span><br><span class="line">ip netns <span class="built_in">exec</span> net2 ip addr add 10.0.2.22/24 dev mac2 mode bridge</span><br><span class="line">ip netns <span class="built_in">exec</span> net2 ip link <span class="built_in">set</span> mac2 up</span><br><span class="line">ip netns <span class="built_in">exec</span> net2 route add default gw 10.0.2.2</span><br><span class="line"></span><br><span class="line">ip netns <span class="built_in">exec</span> net1 ping 10.0.2.22</span><br><span class="line">ip netns <span class="built_in">exec</span> net2 ping 10.0.2.21</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 mode ,net1，net2 没有ping 通</span></span><br><span class="line">ip netns <span class="built_in">exec</span> net2 ip link <span class="built_in">set</span> mac2 <span class="built_in">type</span> macvlan mode private</span><br><span class="line">ip netns <span class="built_in">exec</span> net1 ping 10.0.2.22</span><br><span class="line">ip netns <span class="built_in">exec</span> net2 ping 10.0.2.21</span><br></pre></td></tr></table></figure>

<p>macvlan 在 docker 中应用测试</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 单机</span></span><br><span class="line">docker network create -d macvlan --subnet=10.0.2.0/24 --gateway=10.0.2.2 -o parent=eth0 macvlan0</span><br><span class="line"></span><br><span class="line">docker run --rm -dit --network macvlan0  --name c1 busybox sh</span><br><span class="line">docker run --rm -dit --network macvlan0  --name c2 busybox sh</span><br><span class="line">docker <span class="built_in">exec</span> -it c1 ping c2</span><br><span class="line">docker <span class="built_in">exec</span> -it c2 ping c1</span><br><span class="line"></span><br><span class="line"><span class="comment"># baidu</span></span><br><span class="line">docker <span class="built_in">exec</span> -it c2 ping 180.97.33.108</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. macvlan 跨主机通信</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 一定需要对网卡开启混杂模式 ，特别是虚拟机的设置。</span></span><br><span class="line">sudo ip link <span class="built_in">set</span> eth1  promisc [on|off]</span><br><span class="line"></span><br><span class="line"><span class="comment"># host A</span></span><br><span class="line">docker network create -d macvlan --subnet=192.168.99.0/24 --gateway=192.168.99.1 -o parent=eth1 macvlan1</span><br><span class="line">docker run --rm -dit --network macvlan1  --name c3 --ip 192.168.99.201 busybox sh</span><br><span class="line"><span class="comment"># host B</span></span><br><span class="line">docker network create -d macvlan --subnet=192.168.99.0/24 --gateway=192.168.99.1 -o parent=eth1 macvlan1</span><br><span class="line">docker run --rm -dit --network macvlan1  --name c3 --ip 192.168.99.202 busybox sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#Host a</span></span><br><span class="line">docker <span class="built_in">exec</span> -it c3 ping 192.168.99.202</span><br><span class="line"></span><br><span class="line"><span class="comment"># host b</span></span><br><span class="line">docker <span class="built_in">exec</span> -it c3 ping 192.168.99.201</span><br></pre></td></tr></table></figure>

<h2 id="none"><a href="#none" class="headerlink" title="none"></a>none</h2><p>none 模式，使用 <code>--network=none</code> 指定。</p>
<p>在这种模式下，容器有独立的网络栈，但不包含任何网络配置，只具有 lo 这个 <code>loopback</code> 网卡用于进程通信。也就是说，none 模式为容器做了最少的网络设置，但是俗话说得好“少即是多”，在没有网络配置的情况下，通过第三方工具或者手工的方式，开发这任意定制容器的网络，提供了最高的灵活性。通常，这表明要使用其他的第三方网络驱动器或手动为 Docker 容器添加网卡、配置 IP 等，如使用: <a href="https://github.com/jpetazzo/pipework" target="_blank" rel="noopener">pipework</a> 工具。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="Docker-如何访问宿主机"><a href="#Docker-如何访问宿主机" class="headerlink" title="Docker 如何访问宿主机?"></a>Docker 如何访问宿主机?</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br><span class="line">ip addr show docker0</span><br><span class="line">ip addr show docker0 | grep -Po <span class="string">'inet \K[\d.]+'</span></span><br><span class="line"><span class="comment"># 会看到 docker0 那个 ip，可以使用来访问宿主机</span></span><br><span class="line"><span class="comment"># 一般为 172.17.0.1</span></span><br><span class="line"><span class="comment"># 或者访问当前机器ip(192.168.1.xxx)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># MacOS 中</span></span><br><span class="line"><span class="comment"># docker 18.03 加入了一个 feature，在容器中可以通过 host.docker.internal 来访问主机 。</span></span><br></pre></td></tr></table></figure>

<h3 id="docker-访问宿主机-ip-时"><a href="#docker-访问宿主机-ip-时" class="headerlink" title="docker 访问宿主机 ip 时"></a>docker 访问宿主机 ip 时</h3><p><a href="https://forums.docker.com/t/no-route-to-host-network-request-from-container-to-host-ip-port-published-from-other-container/39063" target="_blank" rel="noopener">NO ROUTE TO HOST network request from container to host-ip:port published from other container</a></p>
<ol>
<li>报错：No route to host</li>
</ol>
<p><code>原因</code>：默认情况下，<code>firewalld</code>将阻止同一个<code>docker</code>主机上的<code>intercontainer</code>网络。要允许<code>docker</code>容器之间的通信，需要防火墙允许<code>docker0 ip</code> 或 自定义创建的<code>network ip</code>通过</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取到相关 IP。容器内用 docker0 IP访问</span></span><br><span class="line">ifconfig</span><br><span class="line">ip addr show docker0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一种 开放要访问的端口</span></span><br><span class="line">firewall-cmd --zone=public --add-port=8081/tcp --permanent</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种</span></span><br><span class="line"><span class="comment"># 用 host 模式</span></span><br><span class="line"><span class="comment"># 注意：host 模式 就不能绑定端口了，所有容器端口都对应属主机端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三种</span></span><br><span class="line"><span class="comment"># 注意这里的 172.17.0.0/16 可以匹配 172.17.xx.xx IP 段的所有 IP.</span></span><br><span class="line">firewall-cmd --permanent --zone=public --add-rich-rule=<span class="string">'rule family=ipv4 source address=172.17.0.0/16 accept'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="comment"># /etc/firewalld/zones/public.xml 中添加防火墙规则</span></span><br><span class="line">&lt;rule family=<span class="string">"ipv4"</span>&gt;</span><br><span class="line">  &lt;<span class="built_in">source</span> address=<span class="string">"172.17.0.0/16"</span> /&gt;</span><br><span class="line">  &lt;accept /&gt;</span><br><span class="line">&lt;/rule&gt;</span><br><span class="line"></span><br><span class="line">firewall-cmd --reload</span><br><span class="line">systemctl restart docker</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果还不好用检测检查</span></span><br><span class="line">/etc/hosts.allow and hosts.deny</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还不好用，再尝试清空防火墙规则，并重启docker服务来解决。因为docker是通过iptables来配置网络时间的隔离的，有时可能会配置出错误的条目，使得内部容器的访问出现问题。</span></span><br><span class="line"></span><br><span class="line">iptables -F &amp;&amp; iptables -X &amp;&amp; iptables -Z &amp;&amp; iptables -t nat -F</span><br><span class="line">systemctl restart docker.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 还不好用……执行以下代码</span></span><br><span class="line">nmcli connection modify docker0 connection.zone trusted</span><br><span class="line">systemctl stop NetworkManager.service</span><br><span class="line">firewall-cmd --permanent --zone=trusted --change-interface=docker0</span><br><span class="line">systemctl start NetworkManager.service</span><br><span class="line">nmcli connection modify docker0 connection.zone trusted</span><br><span class="line">systemctl restart docker.service</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>Host is unreachable (Host unreachable)</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取网络 ip</span></span><br><span class="line">docker network ls</span><br><span class="line">docker inspect &lt;network id&gt;</span><br><span class="line"></span><br><span class="line"><span class="string">"IPAM"</span>: &#123;</span><br><span class="line">  <span class="string">"Config"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">"Subnet"</span>: <span class="string">"192.168.48.0/20"</span>,</span><br><span class="line">      <span class="string">"Gateway"</span>: <span class="string">"192.168.48.1"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">firewall-cmd --zone=trusted --add-source=172.17.0.1/16 --permanent</span><br><span class="line">firewall-cmd --zone=trusted --add-source=192.168.48.1/20 --permanent</span><br><span class="line"></span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure>

<h3 id="容器间如何访问？"><a href="#容器间如何访问？" class="headerlink" title="容器间如何访问？"></a>容器间如何访问？</h3><ol>
<li>在容器内可以通过 docker0 ip + 容器对外暴露的端口来访问其他容器</li>
<li>可以通过 service name + 容器内部端口来访问</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://docs.docker.com/network/" target="_blank" rel="noopener">docker network</a></li>
<li><a href="https://yeasy.gitbooks.io/docker_practice/content/network/" target="_blank" rel="noopener">docker practice</a></li>
<li><a href="https://www.jianshu.com/p/c83a9173459f/" target="_blank" rel="noopener">Docker swarm中的LB和服务发现详解</a></li>
<li><a href="https://www.jianshu.com/p/dba9342071d8/" target="_blank" rel="noopener">Docker Swarm - 服务发现和负载均衡原理</a></li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/docker/" rel="tag"># docker</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/back-end/linux/linux-ssh-connection-closed-on-connect-xorddos/" rel="prev" title="恶意程序导致 SSH 登录 CentOS7 成功后闪断">
      <i class="fa fa-chevron-left"></i> 恶意程序导致 SSH 登录 CentOS7 成功后闪断
    </a></div>
      <div class="post-nav-item">
    <a href="/back-end/docker/docker-swarm-lb/" rel="next" title="Docker Swarm 之 服务发现和负载均衡原理">
      Docker Swarm 之 服务发现和负载均衡原理 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#外部访问容器"><span class="nav-number">1.</span> <span class="nav-text">外部访问容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Docker-的网络模式"><span class="nav-number">2.</span> <span class="nav-text">Docker 的网络模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bridge"><span class="nav-number">3.</span> <span class="nav-text">bridge</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-bridge"><span class="nav-number">3.1.</span> <span class="nav-text">使用 bridge</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#host"><span class="nav-number">4.</span> <span class="nav-text">host</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-host"><span class="nav-number">4.1.</span> <span class="nav-text">使用 host</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#container-link"><span class="nav-number">5.</span> <span class="nav-text">container link</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-link"><span class="nav-number">5.1.</span> <span class="nav-text">使用 link</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#overlay"><span class="nav-number">6.</span> <span class="nav-text">overlay</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#构建自定义-overlay-网络集群"><span class="nav-number">6.1.</span> <span class="nav-text">构建自定义 overlay 网络集群</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#macvlan"><span class="nav-number">7.</span> <span class="nav-text">macvlan</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-macvaln"><span class="nav-number">7.1.</span> <span class="nav-text">使用 macvaln</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#none"><span class="nav-number">8.</span> <span class="nav-text">none</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#问题"><span class="nav-number">9.</span> <span class="nav-text">问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Docker-如何访问宿主机"><span class="nav-number">9.1.</span> <span class="nav-text">Docker 如何访问宿主机?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#docker-访问宿主机-ip-时"><span class="nav-number">9.2.</span> <span class="nav-text">docker 访问宿主机 ip 时</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#容器间如何访问？"><span class="nav-number">9.3.</span> <span class="nav-text">容器间如何访问？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">10.</span> <span class="nav-text">参考</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Richard"
      src="https://avatars3.githubusercontent.com/u/18113256?v=3&s=460">
  <p class="site-author-name" itemprop="name">Richard</p>
  <div class="site-description" itemprop="description">惶者生存，偏执者成功</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">132</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">59</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xinlc" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xinlc" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://twitter.com/xinlc" title="Twitter → https:&#x2F;&#x2F;twitter.com&#x2F;xinlc" rel="noopener" target="_blank"><i class="fab fa-twitter fa-fw"></i>Twitter</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://learnxinyminutes.com/" title="https:&#x2F;&#x2F;learnxinyminutes.com" rel="noopener" target="_blank">Learn X in Y minutes</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://justjavac.com/" title="http:&#x2F;&#x2F;justjavac.com" rel="noopener" target="_blank">justjavac</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.ruanyifeng.com/blog/" title="http:&#x2F;&#x2F;www.ruanyifeng.com&#x2F;blog&#x2F;" rel="noopener" target="_blank">阮一峰</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.liaoxuefeng.com/" title="https:&#x2F;&#x2F;www.liaoxuefeng.com" rel="noopener" target="_blank">廖雪峰</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://tech.meituan.com/" title="https:&#x2F;&#x2F;tech.meituan.com" rel="noopener" target="_blank">美团技术</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.v2ex.com/" title="https:&#x2F;&#x2F;www.v2ex.com" rel="noopener" target="_blank">V2EX</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://caniuse.com/" title="https:&#x2F;&#x2F;caniuse.com" rel="noopener" target="_blank">caniuse/工具</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://www.css88.com/nav/" title="http:&#x2F;&#x2F;www.css88.com&#x2F;nav&#x2F;" rel="noopener" target="_blank">css88/doc</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://overapi.com/" title="http:&#x2F;&#x2F;overapi.com&#x2F;" rel="noopener" target="_blank">OverAPI/api</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://devdocs.io/" title="http:&#x2F;&#x2F;devdocs.io&#x2F;" rel="noopener" target="_blank">DevDocs/api</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://tool.oschina.net/" title="http:&#x2F;&#x2F;tool.oschina.net&#x2F;" rel="noopener" target="_blank">在线工具/索引</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://tool.lu/" title="http:&#x2F;&#x2F;tool.lu&#x2F;" rel="noopener" target="_blank">ToolBox</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="http://hao.shejidaren.com/" title="http:&#x2F;&#x2F;hao.shejidaren.com&#x2F;" rel="noopener" target="_blank">设计导航</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Richard</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>














  

  

</body>
</html>
